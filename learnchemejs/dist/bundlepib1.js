/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./prb/pib1.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./prb/pib1.js":
/*!*********************!*\
  !*** ./prb/pib1.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-undef */\n\n\nvar _GraphCanvas = __webpack_require__(/*! ../src/GraphCanvas.js */ \"./src/GraphCanvas.js\");\n\nvar _hsvToRgb = __webpack_require__(/*! ../src/hsvToRgb.js */ \"./src/hsvToRgb.js\");\n\nvar _skyHelpers = __webpack_require__(/*! ../src/sky-helpers.js */ \"./src/sky-helpers.js\");\n\nvar _Modal = __webpack_require__(/*! ../src/Modal.js */ \"./src/Modal.js\");\n\nvar _modalFill = __webpack_require__(/*! ../src/modalFill.js */ \"./src/modalFill.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Sim = function () {\n    function Sim() {\n        _classCallCheck(this, Sim);\n\n        this.defineGlobals();\n        this.insertPageElements();\n        this.attachListeners();\n        window.setInterval(this.nextFrame.bind(this), 1000 / this.FPS);\n        this.init();\n    }\n\n    _createClass(Sim, [{\n        key: 'init',\n        value: function init() {\n            this.changeCoefficients();\n            this.getNs();\n            this.getMass();\n            this.getLength();\n            this.update();\n            var modalFiles = [];\n            modalFiles.push((0, _modalFill.modalFill)(this.modalDetails, '../html/modalHTML/pib1DetailsContent.html.txt'));\n            modalFiles.push((0, _modalFill.modalFill)(this.modalDirections, '../html/modalHTML/pib1DirectionsContent.html.txt'));\n            modalFiles.push((0, _modalFill.modalFill)(this.modalAbout, '../html/modalHTML/pib1AboutContent.html.txt'));\n            var error1 = this.modalDetails;\n            var error2 = this.modalDirections;\n            Promise.all(modalFiles).then(function () {\n                MathJax.Hub.Configured();\n            }).catch(function () {\n                console.log(\"MathJax Not Yet Loaded ...\");\n                var delay = 1000;\n                setTimeout(function jax() {\n                    try {\n                        MathJax.Hub.Configured();\n                    } catch (error) {\n                        console.error(error);if (delay < 10000) {\n                            delay *= 1.5;setTimeout(jax, delay);\n                        } else {\n                            (0, _modalFill.modalFill)(error1, '../html/modalHTML/errorText.html.txt');\n                            (0, _modalFill.modalFill)(error2, '../html/modalHTML/errorText.html.txt');\n                        }\n                    }\n                }, delay);\n            });\n        }\n    }, {\n        key: 'defineGlobals',\n        value: function defineGlobals() {\n            this.RUNNING = false;\n            this.FPS = 60;\n            this.T = 0;\n            this.TSTEP = 0.2 / this.FPS;\n\n            this.minMass = 0.1;\n            this.maxMass = 10;\n            this.minLength = 0.1;\n            this.maxLength = 10;\n            this.scaleMass = 100; // Sliders cannot use floats\n            this.scaleLength = 100; // Sliders cannot use floats\n\n            this.graphWidth = 420;\n            this.graphHeight = 280;\n            this.graphLeft = 30;\n            this.graphRight = 10;\n            this.graphTop = 10;\n            this.graphBottom = 50;\n            this.xbounds = [0, 1];\n\n            this.MAXCOEFFICIENTS = 6;\n            this.NS = (0, _skyHelpers.linspace)(1, this.MAXCOEFFICIENTS, this.MAXCOEFFICIENTS, true);\n            this.POINTS = 1000;\n\n            this.XS = (0, _skyHelpers.linspace)(this.xbounds[0], this.xbounds[1], this.POINTS + 1, true);\n            this.L = 1;\n            this.M = 1;\n            this.PROBS = [];\n            this.RES = [];\n            this.IMS = [];\n\n            this.detailsContent = \"\";\n            this.directionsContent = \"\";\n            this.aboutContent = \"\";\n\n            this.modalDetails = new _Modal.Modal({ modalid: \"modal-details\", modalclass: \"modal moveUp\", headerstyle: \"\", header: \"Details\", contentstyle: \"\", content: this.detailsContent, showing: false });\n            this.modalDirections = new _Modal.Modal({ modalid: \"modal-directions\", modalclass: \"modal moveUp\", headerstyle: \"\", header: \"Directions\", contentstyle: \"\", content: this.directionsContent, showing: false });\n            this.modalAbout = new _Modal.Modal({ modalid: \"modal-about\", modalclass: \"modal moveUp\", headerstyle: \"\", header: \"About\", contentstyle: \"\", content: this.aboutContent, showing: false });\n        }\n    }, {\n        key: 'insertPageElements',\n        value: function insertPageElements() {\n            var html = '<div id=\"page\">';\n            html += '<div class=\"navbar\">';\n            html += '<button id=\\'details\\' class=\\'buttonMed\\'>details</button>';\n            html += '<button id=\\'directions\\' class=\\'buttonMed\\'>directions</button>';\n            html += '<button id=\\'about\\' class=\\'buttonMed\\'>about</button>';\n            html += '</div>';\n            html += '<div class=\"row\">';\n            html += '<div id=\"left\" class=\"column\"></div>';\n            html += '<div id=\"right\" class=\"column\"></div>';\n            html += '</div>';\n            html += '</div>';\n            document.body.insertAdjacentHTML(\"beforeend\", html);\n\n            // Insert coefficient table\n            html = '<div id=\"coefficients\">';\n            html += '<table>';\n            html += '<th>n</th><th>C<sub>n</sub></th>';\n            for (var row = 1; row < this.MAXCOEFFICIENTS + 1; row++) {\n                html += '<tr>';\n                html += '<td class=\"table dark\"><input id=\"n-' + row + '\" class=\"tableinput\" value=\"' + this.NS[row - 1] + '\" placeholder=\"' + row + '\"></input></td>';\n                html += '<td class=\"table light\"><input id=\"cn-' + row + '\" class=\"tableinput\" value=\"' + (row == 1 ? 1 : 0) + '\" placeholder=\"0\" tabindex=\"' + row + '\"></input></td>';\n                html += '</tr>';\n            }\n            html += '</table>';\n            html += '</div>';\n            document.getElementById(\"left\").insertAdjacentHTML(\"beforeend\", html);\n\n            // Insert buttons\n            html = '<div id=\"buttons\">';\n            html += '<button id=\\'resetc\\'>reset t = 0</button>';\n            html += '<button id=\\'reset\\'>reset defaults</button>';\n            html += '<button id=\\'togglec\\'>start/stop</button>';\n            html += '<br>';\n            html += '<button id=\\'measure\\'>measure E</button>';\n            html += '<button id=\\'integrate\\'>integrate</button>';\n            html += '</div>';\n            document.getElementById(\"left\").insertAdjacentHTML(\"beforeend\", html);\n\n            // Insert integral box\n            html = '<div id=\"integral\">';\n            html += '<table>';\n            html += '<th>x<sub>1</sub></th><th>x<sub>2</sub></th><th>integral</th>';\n            html += '<tr><td><input id=\"x1\" class=\"tableinput\" value=\"' + 0 + '\" placeholder=\"0\"></input></td>';\n            html += '<td><input id=\"x2\" class=\"tableinput\" value=\"' + 1 + '\" placeholder=\"0\"></input></td>';\n            html += '<td><input id=\"int\" class=\"tableinput\" placeholder=\"-\" readonly></input></td>';\n            html += '</tr></table>';\n            html += '</div>';\n            document.getElementById(\"left\").insertAdjacentHTML(\"beforeend\", html);\n\n            // Insert sliders\n            html = '<div id=\"sliders\" class=\"row\">';\n            html += '<div class=\"sliderdiv\">';\n            html += '<p id=\"spanmass\" class=\"sliderp\">Mass</p>';\n            html += '<input type=\"range\" min=\"' + this.minMass * this.scaleMass + '\" max=\"' + this.maxMass * this.scaleMass + '\" value=\"' + this.M * this.scaleMass + '\" class=\"slider\" id=\"sldmass\">';\n            html += '</div>';\n            html += '<div class=\"sliderdiv\">';\n            html += '<p id=\"spanlength\" class=\"sliderp\">Length</p>';\n            html += '<input type=\"range\" min=\"' + this.minLength * this.scaleLength + '\" max=\"' + this.maxLength * this.scaleLength + '\" value=\"' + this.L * this.scaleLength + '\" class=\"slider\" id=\"sldlength\">';\n            html += '</div>';\n            html += '</div>';\n            document.getElementById(\"left\").insertAdjacentHTML(\"beforeend\", html);\n\n            // Define graph layouts\n            var probgraphinfo = {\n                \"graphwidth\": this.graphWidth,\n                \"graphheight\": this.graphHeight,\n                \"padding\": {\n                    \"left\": this.graphLeft,\n                    \"bottom\": this.graphBottom,\n                    \"top\": this.graphTop,\n                    \"right\": this.graphRight\n                },\n                \"graphbackground\": \"white\",\n                \"axesbackground\": \"white\",\n                \"x\": {\n                    \"label\": \"x / L\",\n                    \"min\": this.xbounds[0],\n                    \"max\": this.xbounds[1],\n                    \"majortick\": 0.2,\n                    \"minortick\": 0.2,\n                    \"gridline\": 1\n                },\n                \"y\": {\n                    \"label\": \"\",\n                    \"min\": 0,\n                    \"max\": 5,\n                    \"majortick\": 1,\n                    \"minortick\": 1,\n                    \"gridline\": 5\n                }\n            };\n\n            var compgraphinfo = {\n                \"graphwidth\": this.graphWidth,\n                \"graphheight\": this.graphHeight,\n                \"padding\": {\n                    \"left\": this.graphLeft,\n                    \"bottom\": this.graphBottom,\n                    \"top\": this.graphTop,\n                    \"right\": this.graphRight\n                },\n                \"graphbackground\": \"white\",\n                \"axesbackground\": \"white\",\n                \"x\": {\n                    \"label\": \"x / L\",\n                    \"min\": this.xbounds[0],\n                    \"max\": this.xbounds[1],\n                    \"majortick\": 0.2,\n                    \"minortick\": 0.2,\n                    \"gridline\": 1\n                },\n                \"y\": {\n                    \"label\": \"\",\n                    \"min\": -3,\n                    \"max\": 3,\n                    \"majortick\": 1,\n                    \"minortick\": 1,\n                    \"gridline\": 3\n                }\n            };\n\n            var energygraphinfo = {\n                \"graphwidth\": this.graphWidth,\n                \"graphheight\": this.graphHeight,\n                \"padding\": {\n                    \"left\": this.graphLeft,\n                    \"bottom\": this.graphBottom,\n                    \"top\": this.graphTop,\n                    \"right\": this.graphRight\n                },\n                \"graphbackground\": \"white\",\n                \"axesbackground\": \"white\",\n                \"x\": {\n                    \"label\": \"x / L\",\n                    \"min\": this.xbounds[0],\n                    \"max\": this.xbounds[1],\n                    \"majortick\": 0.2,\n                    \"minortick\": 0.2,\n                    \"gridline\": 1\n                },\n                \"y\": {\n                    \"label\": \"\",\n                    \"min\": 0,\n                    \"max\": 60,\n                    \"majortick\": 10,\n                    \"minortick\": 10,\n                    \"gridline\": 60\n                }\n            };\n\n            // Create graphs\n            document.getElementById(\"right\").insertAdjacentHTML(\"beforeend\", '<span class=\"graphtitle\">Probability Density |\\u03C8|\\xB2 (=\\u03C8*\\u03C8)</span>');\n            this.densitygc = new _GraphCanvas.GraphCanvas(\"density-gc\", \"right\", {\n                graphinfo: probgraphinfo\n            });\n\n            document.getElementById(\"right\").insertAdjacentHTML(\"beforeend\", '<span class=\"graphtitle\">Real & Imaginary Components</span>');\n            this.componentgc = new _GraphCanvas.GraphCanvas(\"component-gc\", \"right\", {\n                graphinfo: compgraphinfo\n            });\n\n            document.getElementById(\"left\").insertAdjacentHTML(\"beforeend\", '<span class=\"graphtitle\">Energy (kJ / mol)</span>');\n            this.energygc = new _GraphCanvas.GraphCanvas(\"energy-gc\", \"left\", {\n                graphinfo: energygraphinfo\n            });\n        }\n    }, {\n        key: 'attachListeners',\n        value: function attachListeners() {\n            var _this = this;\n\n            // Buttons\n            document.getElementById('togglec').addEventListener(\"click\", function () {\n                return _this.toggleRunning();\n            });\n            document.getElementById('resetc').addEventListener(\"click\", function () {\n                return _this.resetTime();\n            });\n            document.getElementById('reset').addEventListener(\"click\", function () {\n                return location.reload();\n            });\n            document.getElementById('measure').addEventListener(\"click\", function () {\n                return _this.measureE();\n            });\n            document.getElementById('integrate').addEventListener(\"click\", function () {\n                return _this.integrate();\n            });\n            // Input events\n            for (var i = 1; i <= this.MAXCOEFFICIENTS; i++) {\n                document.getElementById('n-' + i).addEventListener(\"input\", function () {\n                    return _this.changeCoefficients();\n                });\n                document.getElementById('cn-' + i).addEventListener(\"input\", function () {\n                    return _this.changeCoefficients();\n                });\n            }\n            document.getElementById('sldmass').addEventListener(\"input\", function () {\n                return _this.getMass();\n            });\n            document.getElementById('sldlength').addEventListener(\"input\", function () {\n                return _this.getLength();\n            });\n            document.getElementById('details').addEventListener(\"click\", function () {\n                return _this.modalDetails.show();\n            });\n            document.getElementById('directions').addEventListener(\"click\", function () {\n                return _this.modalDirections.show();\n            });\n            document.getElementById('about').addEventListener(\"click\", function () {\n                return _this.modalAbout.show();\n            });\n        }\n    }, {\n        key: 'nextFrame',\n        value: function nextFrame() {\n            if (this.RUNNING) this.update();\n        }\n    }, {\n        key: 'update',\n        value: function update() {\n            this.T += this.TSTEP;\n            this.calculatePsi();\n            this.clearGraphs();\n            this.drawGraphs();\n        }\n    }, {\n        key: 'calculatePsi',\n        value: function calculatePsi() {\n            var _this2 = this;\n\n            var freqs = this.NS.map(function (n) {\n                return 2 * math.pi * math.pow(n / (_this2.M * _this2.L), 2);\n            }); /*Proportional to n^2/(m L^2)*/\n            var PhaseShifts = freqs.map(function (freq) {\n                return math.exp(math.complex(0, -freq * _this2.T));\n            });\n\n            // let InitialStates = math.multiply(math.dotMultiply(math.transpose(math.matrix([this.NS])), math.pi), math.matrix([this.XS]));\n            // InitialStates = InitialStates.forEach(function (value, index, matrix) {return math.sqrt(2 / 1) * math.sin(value * math.PI)});\n\n            this.PSI = [];\n            this.PROBS = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.XS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var x = _step.value;\n\n                    var TimeEvolved = [];\n                    for (var _i = 0; _i < this.coefficients.length; _i++) {\n                        var InitialState = math.sqrt(2 / this.L) * math.sin(this.NS[_i] * math.pi * x);\n                        var WeightedState = InitialState * this.coefficients[_i];\n                        var te = math.prod(WeightedState, PhaseShifts[_i]);\n                        TimeEvolved.push(te);\n                    }\n                    var psi = math.sum(TimeEvolved);\n                    // psi = math.re(math.prod(math.conj(psi), psi));\n                    this.PSI.push(psi);\n                    this.PROBS.push(math.re(math.prod(psi, math.conj(psi))));\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            var int = this.riemanntrapezoid(this.XS, this.PROBS, 0, 1, false);\n            this.NORMPSI = [];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.PSI[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var psi = _step2.value;\n\n                    this.NORMPSI.push(math.divide(psi, Math.pow(int * this.L, 0.5)));\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this.PROBS = [];\n            this.RES = [];\n            this.IMS = [];\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.NORMPSI[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var _psi = _step3.value;\n\n                    this.PROBS.push(math.re(math.prod(_psi, math.conj(_psi))));\n                    this.RES.push(math.re(_psi));\n                    this.IMS.push(math.im(_psi));\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            this.ENERGY = 0;\n            for (var i = 0; i < this.MAXCOEFFICIENTS; i++) {\n                var level = Math.pow(this.NS[i], 2) / Math.pow(8 * 1.67 * this.M * this.L, 2) * Math.pow(6.62, 2) * 6.02;\n                this.ENERGY += level * this.scaledcoefficients[i];\n            }\n        }\n    }, {\n        key: 'clearGraphs',\n        value: function clearGraphs() {\n            this.densitygc.clear();\n            this.componentgc.clear();\n            this.energygc.clear();\n        }\n    }, {\n        key: 'drawGraphs',\n        value: function drawGraphs() {\n            this.densitygc.drawLine(this.XS, this.PROBS, (0, _hsvToRgb.hsvToRgb)(0, 0, 0), 3);\n\n            this.componentgc.drawText('Re', 0.93, 2.8, { 'color': 'blue' });\n            this.componentgc.drawText('Im', 0.93, 2.3, { 'color': 'red' });\n            this.componentgc.drawLine(this.XS, this.RES, (0, _hsvToRgb.hsvToRgb)(220, 100, 100), 3);\n            this.componentgc.drawLine(this.XS, this.IMS, (0, _hsvToRgb.hsvToRgb)(0, 100, 100), 3);\n\n            for (var i = 0; i < this.MAXCOEFFICIENTS; i++) {\n                var level = Math.pow(this.NS[i], 2) / Math.pow(8 * 1.67 * this.M * this.L, 2) * Math.pow(6.62, 2) * 6.02;\n                this.energygc.drawLine(this.xbounds, [level, level], (0, _hsvToRgb.hsvToRgb)(0, 0, 0), 1, [2, 2]);\n            }\n            this.energygc.drawLine(this.xbounds, [this.ENERGY, this.ENERGY], (0, _hsvToRgb.hsvToRgb)(0, 100, 100), 3);\n        }\n    }, {\n        key: 'toggleRunning',\n        value: function toggleRunning() {\n            this.RUNNING = !this.RUNNING;\n        }\n    }, {\n        key: 'resetTime',\n        value: function resetTime() {\n            this.RUNNING = false;\n            this.T = 0;\n            this.getCoefficients();\n            this.update();\n        }\n    }, {\n        key: 'changeCoefficients',\n        value: function changeCoefficients() {\n            this.getNs();\n            this.getCoefficients();\n            this.resetTime();\n        }\n    }, {\n        key: 'measureE',\n        value: function measureE() {\n            this.getCoefficients();\n            var cumsum = [];\n            var levels = [];\n            for (var i = 0; i < this.MAXCOEFFICIENTS; i++) {\n                levels.push(0);\n                var last = i > 0 ? cumsum[i - 1] : 0;\n                cumsum.push(last + this.scaledcoefficients[i]);\n            }\n            var probe = Math.random();\n            for (var _i2 = 0; _i2 < this.MAXCOEFFICIENTS; _i2++) {\n                if (probe < cumsum[_i2]) {\n                    levels[_i2] = 1;\n                    break;\n                }\n            }\n            this.coefficients = levels;\n            this.update();\n        }\n    }, {\n        key: 'riemanntrapezoid',\n        value: function riemanntrapezoid(x, y, x1, x2) {\n            var draw = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n            var int = 0;\n            for (var i = 0; i < x.length; i += 1) {\n                if (x[i] >= x1 && x[i + 1] <= x2) {\n                    int += (y[i] + y[i + 1]) / 2 * (x[i + 1] - x[i]);\n                    if (draw) this.densitygc.fillLine([x[i], x[i], x[i + 1], x[i + 1]], [0, y[i], y[i + 1], 0], (0, _hsvToRgb.hsvToRgb)(0, 100, 100));\n                }\n            }\n            return int;\n        }\n    }, {\n        key: 'integrate',\n        value: function integrate() {\n            this.RUNNING = false;\n            this.clearGraphs();\n            var x1 = Number(document.getElementById('x1').value);\n            var x2 = Number(document.getElementById('x2').value);\n            var fullint = this.riemanntrapezoid(this.XS, this.PROBS, 0, 1, false);\n            var int = this.riemanntrapezoid(this.XS, this.PROBS, x1, x2, true) / fullint;\n            this.drawGraphs();\n            var digits = 4;\n            document.getElementById('int').value = Math.round(int * Math.pow(10, digits), digits) / Math.pow(10, digits);\n        }\n    }, {\n        key: 'getCoefficients',\n        value: function getCoefficients() {\n            this.coefficients = [];\n            this.scaledcoefficients = [];\n            var sum = 0;\n            for (var i = 1; i <= this.MAXCOEFFICIENTS; i++) {\n                var val = parseFloat(document.getElementById('cn-' + i).value);\n                this.coefficients.push(val);\n                this.scaledcoefficients.push(val);\n                sum += val;\n            }\n            this.scaledcoefficients.forEach(function (value, index, array) {\n                return array[index] /= sum;\n            });\n        }\n    }, {\n        key: 'getNs',\n        value: function getNs() {\n            this.NS = [];\n            for (var i = 1; i <= this.MAXCOEFFICIENTS; i++) {\n                var val = parseFloat(document.getElementById('n-' + i).value);\n                if (val == 0) val = i;\n                this.NS.push(val);\n            }\n        }\n    }, {\n        key: 'setCoefficients',\n        value: function setCoefficients(coefficients) {\n            for (var i = 0; i < this.MAXCOEFFICIENTS; i++) {\n                document.getElementById('cn-' + (i + 1)).value = coefficients[i];\n            }\n        }\n    }, {\n        key: 'getMass',\n        value: function getMass() {\n            var value = document.getElementById(\"sldmass\").value / this.scaleMass;\n            document.getElementById(\"spanmass\").innerHTML = 'Mass: ' + value;\n            this.M = value;\n            this.update();\n        }\n    }, {\n        key: 'getLength',\n        value: function getLength() {\n            var value = document.getElementById(\"sldlength\").value / this.scaleLength;\n            document.getElementById(\"spanlength\").innerHTML = 'Length: ' + value;\n            this.L = value;\n            this.update();\n        }\n    }]);\n\n    return Sim;\n}();\n\n// eslint-disable-next-line no-unused-vars\n\n\nvar Simulation = new Sim();\n\n//# sourceURL=webpack:///./prb/pib1.js?");

/***/ }),

/***/ "./src/ChemFunctions.js":
/*!******************************!*\
  !*** ./src/ChemFunctions.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Antoine = Antoine;\nexports.InvAntoine = InvAntoine;\nexports.BubblePoint = BubblePoint;\nexports.DewPoint = DewPoint;\nexports.BubblePointT = BubblePointT;\nfunction Antoine(T, A, B, C) {\n    return Math.pow(10, A - B / (T + C));\n}\n\nfunction InvAntoine(P, A, B, C) {\n    return B / (A - Math.log10(P)) - C;\n}\n\nfunction BubblePoint(x, Psat1, Psat2) {\n    return x * Psat1 + (1 - x) * Psat2;\n}\n\nfunction DewPoint(x, Psat1, Psat2) {\n    return Math.pow(x / Psat1 + (1 - x) / Psat2, -1);\n}\n\nfunction BubblePointT(x, Antoine1, Antoine2, Tmin, Tmax, precision) {\n    return FindRoot({\n        expression: '@x2@ * Antoine(T, @AH@, @BH@, @CH@) + (1 - @x2@) * Antoine(T, @AO@, @BO@, @CO@) - @P@',\n        variable: 'T',\n        min: Tmin,\n        max: Tmax,\n        precision: precision\n    });\n}\n\n//# sourceURL=webpack:///./src/ChemFunctions.js?");

/***/ }),

/***/ "./src/DOM.js":
/*!********************!*\
  !*** ./src/DOM.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar VAR = \"@\";\n\n/**\r\n    Document object model for the page\r\n*/\nvar DOM = exports.DOM = {\n    \"problemdivid\": \"lce_problem\",\n    \"headerdivid\": \"header\",\n    \"bodydivid\": \"body\",\n    \"titledivid\": \"title\",\n    \"stepdivid\": \"step\",\n    \"questiondivid\": \"question\",\n    \"canvasdivclass\": \"canvasarea\",\n    \"canvasdivid\": \"canvasarea--\" + VAR + \"id\" + VAR,\n    \"canvasclass\": \"canvas\",\n    \"canvasid\": \"canvas--\" + VAR + \"id\" + VAR,\n    \"staticcanvasid\": \"canvas--static--\" + VAR + \"id\" + VAR,\n    \"dynamiccanvasid\": \"canvas--dynamic--\" + VAR + \"id\" + VAR,\n    \"canvasinfodivclass\": \"canvasinfo\",\n    \"canvaspointclass\": \"canvaspoint\",\n    \"canvaspointid\": \"canvaspoint--\" + VAR + \"id\" + VAR,\n    \"canvasmodeclass\": \"canvasmode\",\n    \"canvasmodeid\": \"canvasmode--\" + VAR + \"id\" + VAR,\n    \"textboxdivclass\": \"textentry\",\n    \"textboxspanclass\": \"textboxlabel\",\n    \"textboxclass\": \"textbox\",\n    \"textboxid\": \"textbox--\" + VAR + \"id\" + VAR,\n    \"textboxanswerclass\": \"textboxanswer\",\n    \"textboxanswerid\": \"textboxanswer--\" + VAR + \"id\" + VAR,\n    \"textboxanswershown\": \"textboxanswershown\",\n    \"textspanclass\": \"textspan\",\n    \"buttonsdivid\": \"buttons\",\n    \"beginbuttonid\": \"beginbutton\",\n    \"restartbuttonid\": \"restartbutton\",\n    \"restartzeroid\": \"restartzero\",\n    \"restartoneid\": \"restartone\",\n    \"restartabortid\": \"restartabort\",\n    \"hintbuttonid\": \"hintbutton\",\n    \"submitbuttonid\": \"submitbutton\",\n    \"nextbuttonid\": \"nextbutton\",\n    \"scorebuttonid\": \"scorebutton\",\n    \"showgradebuttonid\": \"showgradebutton\",\n    \"feedbackbuttonid\": \"feedbackbutton\",\n    \"scoredivid\": \"scorediv\",\n    \"scoretitleid\": \"scoretitle\",\n    \"currentquestionid\": \"currentquestion\",\n    \"lastscorerowid\": \"lastscorerow\",\n    \"gradedivid\": \"submitgrade\",\n    \"gradeformid\": \"gradeform\",\n    \"gradenametextid\": \"gradenametext\",\n    \"gradecuidtextid\": \"gradecuidtext\",\n    \"gradecoursetextid\": \"gradeclasstext\",\n    \"submitgradebuttonid\": \"submitgradebutton\",\n    \"gradeservererrorid\": \"gradeservererror\",\n    \"feedbackdivid\": \"feedback\",\n    \"feedbackformid\": \"feedbackform\",\n    \"feedbacknametextid\": \"feedbacknametext\",\n    \"feedbackemailtextid\": \"feedbackemailtext\",\n    \"feedbackinputtextid\": \"feedbackinputtext\",\n    \"submitfeedbackbuttonid\": \"submitfeedbackbutton\",\n    \"feedbackservererrorid\": \"feedbackservererror\",\n    \"modaldivid\": \"modaldiv\",\n    \"modalclass\": \"modal\",\n    \"restartmodal\": \"restartmodal\",\n    \"gradesubmitmodal\": \"gradesubmitmodal\",\n    \"feedbackmodal\": \"feedbackmodal\",\n    \"footerdivid\": \"footer\",\n    \"hiddentextclass\": \"hiddentext\",\n    \"hiddenclass\": \"hidden\",\n    \"disabledclass\": \"disabled\",\n    \"hidescoreclass\": \"hidescore\",\n\n    \"tipboxdivclass\": \"tipbox\",\n    \"tipboxdivid\": \"tipbox--\" + VAR + \"id\" + VAR,\n    \"tipboxtextclass\": \"tiptext\",\n    \"tipboxcheckid\": \"tipcheck--\" + VAR + \"id\" + VAR,\n    \"tipboxdontshowclass\": \"tipdontshow\",\n    \"tipboxbuttonclass\": \"tipbutton\",\n    \"tipboxbuttonid\": \"tipbutton--\" + VAR + \"id\" + VAR\n};\n\n//# sourceURL=webpack:///./src/DOM.js?");

/***/ }),

/***/ "./src/GraphCanvas.js":
/*!****************************!*\
  !*** ./src/GraphCanvas.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.GraphCanvas = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ZCanvas = __webpack_require__(/*! ./ZCanvas.js */ \"./src/ZCanvas.js\");\n\nvar _Point = __webpack_require__(/*! ./Point.js */ \"./src/Point.js\");\n\nvar _Line = __webpack_require__(/*! ./Line.js */ \"./src/Line.js\");\n\nvar _Text = __webpack_require__(/*! ./Text.js */ \"./src/Text.js\");\n\nvar _Graphinfo = __webpack_require__(/*! ./Graphinfo.js */ \"./src/Graphinfo.js\");\n\nvar _skyHelpers = __webpack_require__(/*! ./sky-helpers.js */ \"./src/sky-helpers.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar GRABRADIUS = 10;\n\n/**\r\n    Controller class for HTML canvas objects<br>\r\n    Uses two overlaid canvases for background and foreground drawing.\r\n*/\n\nvar GraphCanvas = exports.GraphCanvas = function () {\n    /**\r\n        @param {object} args Object of input arguments\r\n    */\n    function GraphCanvas(id, parent, args) {\n        _classCallCheck(this, GraphCanvas);\n\n        // Pull in arguments\n        // this.graphinfo = args.graphinfo;\n        this.graphinfo = new _Graphinfo.GraphInfo(args.graphinfo);\n        this.cursor = args.cursor;\n\n        this.layers = {\n            \"GRID\": 0,\n            \"UNDER\": 1,\n            \"FRAME\": 2,\n            \"OVER\": 3,\n            \"CURSOR\": 4\n        };\n\n        // Retrieve DOM elements\n        var zc = new _ZCanvas.ZCanvas({\n            \"layers\": Object.keys(this.layers).length,\n            \"width\": this.graphinfo.width,\n            \"height\": this.graphinfo.height,\n            \"containerid\": \"\" + id,\n            \"containerclass\": \"graphcanvas\",\n            \"canvasidprefix\": \"graphcanvas--\",\n            \"canvasclass\": \"graphcanvas-canvas\",\n            \"parentid\": parent\n        });\n        this.canvas = zc.canvas;\n        this.ctx = zc.ctx;\n\n        // Set up canvas size\n        this.height = this.graphinfo.height;\n        this.width = this.graphinfo.width;\n\n        // Draw graph layout\n        this.drawGraph();\n\n        // State variables\n        this.drawing = false; /* True when not finished drawing */\n\n        // Constants\n        this.grabradius = GRABRADIUS;\n\n        this.max = [];\n        this.finished = [];\n        // Set max elements of each type, if specified\n        if (args.answercount != undefined) {\n            this.max = args.answercount;\n        }\n        // Set default elements of each type, if specified\n        if (args.default != undefined) {\n            this.default = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = Object.keys(args.default)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var type = _step.value;\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = args.default[type][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var d = _step2.value;\n\n                            this.finished.push(this.dataToElement(type, d));\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n\n        // Set up mouse events\n        // this.canvas[\"top\"].addEventListener(\"mousemove\", e => this.mouseMove(e));\n        // this.canvas[\"top\"].addEventListener(\"mousedown\", e => this.mouseDown(e));\n        // this.canvas[\"top\"].addEventListener(\"mouseup\", e => this.mouseUp(e));\n\n        // Initialize\n        this.update();\n    }\n\n    /**\r\n        Clears the foreground canvas\r\n    */\n\n\n    _createClass(GraphCanvas, [{\n        key: \"clear\",\n        value: function clear() {\n            //this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\n            // Hacky workaround\n            this.canvas[this.layers.UNDER].width = this.canvas[this.layers.UNDER].width;\n            this.canvas[this.layers.OVER].width = this.canvas[this.layers.OVER].width;\n            this.canvas[this.layers.CURSOR].width = this.canvas[this.layers.CURSOR].width;\n        }\n\n        /**\r\n            Updates the canvas to its current state\r\n        */\n\n    }, {\n        key: \"update\",\n        value: function update() {\n            this.clear();\n            // Remove objects if over limits\n            if (this.mode != \"view\") {\n                this.trimLists();\n            }\n            // Draw objects\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.finished[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var obj = _step3.value;\n\n                    this.draw(obj);\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        }\n        /**\r\n            Creates geometric class object from input data\r\n            @param {string} type \"point\", \"line\", or \"text\"\r\n            @param {object} data Object of input arguments for object\r\n            @return {Point|Line|Text} An instance of the chosen class\r\n        */\n\n    }, {\n        key: \"dataToElement\",\n        value: function dataToElement(type, data) {\n            // Append calibration data\n            data.graphinfo = this.graphinfo;\n            // Create appropriate object\n            if (type === \"point\") {\n                return new _Point.Point(data);\n            } else if (type === \"line\") {\n                var ptlist = [];\n                if (data.points) {\n                    // line constructed from list of points\n                    var _iteratorNormalCompletion4 = true;\n                    var _didIteratorError4 = false;\n                    var _iteratorError4 = undefined;\n\n                    try {\n                        for (var _iterator4 = data.points[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                            var ptdata = _step4.value;\n\n                            ptdata.graphinfo = this.graphinfo;\n                            var pt = new _Point.Point(ptdata);\n                            ptlist.push(pt);\n                            if (pt.show) {\n                                this.finished.push(pt);\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError4 = true;\n                        _iteratorError4 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                _iterator4.return();\n                            }\n                        } finally {\n                            if (_didIteratorError4) {\n                                throw _iteratorError4;\n                            }\n                        }\n                    }\n\n                    data.points = ptlist;\n                } else if (data.equation) {\n                    // line constructed from equation\n                    var ind = data.independent;\n                    var dep = data.dependent;\n                    var di = (ind.max - ind.min) / (data.steps - 1);\n                    // Replace independent variable with value\n                    var re = new RegExp(\"\" + SPVAR + data.independent.symbol + SPVAR, \"g\");\n\n                    // Calculate points along line\n                    var i = ind.min;\n                    while (i <= ind.max) {\n                        var _ptdata = {};\n                        _ptdata[ind.symbol] = i;\n                        // Evaluate expression (trusted code provided by the question-creator)\n                        _ptdata[dep.symbol] = (0, _skyHelpers.evalWithContext)(data.equation.replace(re, i));\n                        _ptdata[\"graphinfo\"] = this.graphinfo;\n                        if (data.showpoints) {\n                            _ptdata.show = true;\n                        } else {\n                            _ptdata.show = false;\n                        }\n                        var _pt = new _Point.Point(_ptdata);\n                        ptlist.push(_pt);\n                        if (_pt.show) {\n                            this.finished.push(_pt);\n                        }\n\n                        i += di;\n                    }\n                    if (data.label) {\n                        // Calculate y position\n                        data.label.dependent = (0, _skyHelpers.evalWithContext)(data.equation.replace(re, data.label.independent));\n                        // Calculate slope\n                        var nextpt = (0, _skyHelpers.evalWithContext)(data.equation.replace(re, data.label.independent + di));\n                        var dy = nextpt - data.label.dependent;\n                        var slope = Math.atan(dy * this.graphinfo.y.scale / (di * this.graphinfo.x.scale));\n                        data.label.rotate = 180 / Math.PI * slope;\n                        // Adjust for offset\n                        data.label.independent += data.label.indoffset;\n                        data.label.dependent += data.label.depoffset;\n                    }\n                    data.points = ptlist;\n                }\n                return new _Line.Line(data);\n            } else if (type === \"text\") {\n                data.position.graphinfo = this.graphinfo;\n                return new _Text.Text(data);\n            }\n        }\n        /**\r\n            @param {event} e Mouse event\r\n            @return {Point} Point object at the current location of the mouse cursor\r\n        */\n\n    }, {\n        key: \"getMousePoint\",\n        value: function getMousePoint(e) {\n            return new _Point.Point({ \"rawx\": e.pageX - this.canvas[this.layers.CURSOR].offsetParent.offsetLeft,\n                \"rawy\": e.pageY - this.canvas[this.layers.CURSOR].offsetParent.offsetTop,\n                \"graphinfo\": this.graphinfo });\n        }\n        /**\r\n            Draws an element to the foreground canvas<br>\r\n            To be replaced with Object.draw() calls\r\n            @param {Point|Line|Text} element QuestionElement to be drawn\r\n        */\n\n    }, {\n        key: \"draw\",\n        value: function draw(element) {\n            var layer = undefined;\n            if (element.layer) {\n                layer = element.layer;\n            }\n            this.ctx[element.layer];\n            this.ctx[layer].save();\n            element.draw(this.ctx[layer]);\n            this.ctx[layer].restore();\n        }\n    }, {\n        key: \"drawLine\",\n        value: function drawLine(xs, ys, color, width, dashes) {\n            var ctx = this.ctx[this.layers.UNDER];\n\n            ctx.strokeStyle = \"rgb(\" + color[0] + \",\" + color[1] + \",\" + color[2] + \")\";\n\n            if (width != undefined) {\n                ctx.lineWidth = width;\n            } else {\n                ctx.lineWidth = 1;\n            }\n\n            if (dashes != undefined) {\n                ctx.setLineDash(dashes);\n            } else {\n                ctx.setLineDash([1, 0]);\n            }\n\n            ctx.beginPath();\n            for (var i = 0; i < xs.length; i++) {\n                var drawx = this.graphinfo.x.CalToRaw(xs[i]);\n                var drawy = this.graphinfo.y.CalToRaw(ys[i]);\n                ctx.lineTo(drawx, drawy);\n            }\n            ctx.stroke();\n        }\n    }, {\n        key: \"fillLine\",\n        value: function fillLine(xs, ys, color) {\n            var ctx = this.ctx[this.layers.UNDER];\n\n            ctx.fillStyle = \"rgb(\" + color[0] + \",\" + color[1] + \",\" + color[2] + \")\";\n\n            ctx.beginPath();\n            for (var i = 0; i < xs.length; i++) {\n                var drawx = this.graphinfo.x.CalToRaw(xs[i]);\n                var drawy = this.graphinfo.y.CalToRaw(ys[i]);\n                ctx.lineTo(drawx, drawy);\n            }\n            ctx.fill();\n        }\n    }, {\n        key: \"drawText\",\n        value: function drawText(text, x, y) {\n            var properties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n            var props = properties;\n            props['text'] = text;\n            props['position'] = new _Point.Point({ 'x': x, 'y': y, 'graphinfo': this.graphinfo });\n            new _Text.Text(properties).draw(this.ctx[this.layers.UNDER]);\n        }\n\n        /**\r\n            Draws the background of the graph (background colors, axes, labels)<br>\r\n            Needs serious revision\r\n        */\n\n    }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n            // Border region\n            this.ctx[this.layers.FRAME].fillStyle = this.graphinfo.axesbackground;\n            this.ctx[this.layers.FRAME].fillRect(0, 0, this.graphinfo.width, this.graphinfo.graphtop);\n            this.ctx[this.layers.FRAME].fillRect(0, 0, this.graphinfo.graphleft, this.graphinfo.height);\n            this.ctx[this.layers.FRAME].fillRect(this.graphinfo.graphright, 0, this.graphinfo.width, this.graphinfo.height);\n            this.ctx[this.layers.FRAME].fillRect(0, this.graphinfo.graphbottom, this.graphinfo.width, this.graphinfo.height);\n\n            // Graph region\n            this.ctx[this.layers.GRID].fillStyle = this.graphinfo.graphbackground;\n            this.ctx[this.layers.GRID].fillRect(this.graphinfo.padding.left, this.graphinfo.padding.top, this.graphinfo.graphwidth, this.graphinfo.graphheight);\n\n            // TODO use text measuring to place label text\n\n            // X axis\n            if (this.graphinfo.x != undefined) {\n                this.drawAxis({\n                    axisinfo: this.graphinfo.x,\n                    stepStart: this.graphinfo.padding.left,\n                    stepLimit: this.graphinfo.width - this.graphinfo.padding.right,\n                    axisY0: this.graphinfo.height - this.graphinfo.padding.bottom,\n                    axisY1: this.graphinfo.padding.top,\n                    tickSign: -1,\n                    numberOffset: 10,\n                    labelX: this.graphinfo.graphwidth / 2 + this.graphinfo.padding.left,\n                    labelY: this.graphinfo.height - this.graphinfo.padding.bottom + 40,\n                    labelrotate: 0\n                });\n            }\n            // Y axis\n            if (this.graphinfo.y != undefined) {\n                this.drawAxis({\n                    axisinfo: this.graphinfo.y,\n                    stepStart: this.graphinfo.padding.top,\n                    stepLimit: this.height - this.graphinfo.padding.bottom,\n                    axisX0: this.graphinfo.padding.left,\n                    axisX1: this.graphinfo.padding.left + this.graphinfo.graphwidth,\n                    tickSign: 1,\n                    numberOffset: -20,\n                    labelX: this.graphinfo.padding.left - 50,\n                    labelY: this.graphinfo.graphheight / 2 + this.graphinfo.padding.top,\n                    labelrotate: -90\n                });\n            }\n            // X2 axis\n            if (this.graphinfo.x2 != undefined) {\n                this.drawAxis({\n                    axisinfo: this.graphinfo.x2,\n                    stepStart: this.graphinfo.padding.left,\n                    stepLimit: this.graphinfo.width - this.graphinfo.padding.right,\n                    axisY0: this.graphinfo.padding.top,\n                    axisY1: this.graphinfo.height - this.graphinfo.padding.bottom,\n                    tickSign: 1,\n                    numberOffset: -11,\n                    labelX: this.graphinfo.graphwidth / 2 + this.graphinfo.padding.left,\n                    labelY: this.graphinfo.padding.top - 40,\n                    labelrotate: 0\n                });\n            }\n            // Y2 axis\n            if (this.graphinfo.y2 != undefined) {\n                this.drawAxis({\n                    // TODO test values to make sure they display well\n                    axisinfo: this.graphinfo.y2,\n                    stepStart: this.graphinfo.padding.top,\n                    stepLimit: this.height - this.graphinfo.padding.bottom,\n                    axisX0: this.graphinfo.padding.left,\n                    axisX1: this.graphinfo.padding.left + this.graphinfo.graphwidth,\n                    tickSign: -1,\n                    numberOffset: 20,\n                    labelX: this.graphinfo.padding.left + this.graphinfo.graphwidth + 40,\n                    labelY: this.graphinfo.graphheight / 2 + this.graphinfo.padding.top,\n                    labelrotate: 90\n                });\n            }\n            // Bounding box\n            this.ctx[this.layers.FRAME].rect(this.graphinfo.padding.left, this.graphinfo.padding.top, this.graphinfo.graphwidth, this.graphinfo.graphheight);\n            this.ctx[this.layers.FRAME].strokeStyle = \"black\";\n            this.ctx[this.layers.FRAME].lineWidth = 1;\n            this.ctx[this.layers.FRAME].stroke();\n        }\n        /**\r\n            Abstract method to replace drawGraph\r\n        */\n\n    }, {\n        key: \"drawAxis\",\n        value: function drawAxis(args) {\n            // Constants\n            var MajorAxisTickLength = 10;\n            var MinorAxisTickLength = 5;\n            var LabelDigits = 3;\n            var LabelxDigits = LabelDigits;\n            var LabelyDigits = LabelDigits;\n            var Labelx2Digits = LabelDigits;\n            var Labely2Digits = LabelDigits;\n            var GridColor = \"lightgray\";\n            var GridThickness = 1;\n            var TickColor = \"gray\";\n            var TickThickness = 1;\n            var TextColor = \"black\";\n            var TextFont = \"sans-serif\";\n            var TextFontSize = 20;\n            var TextFontStyle = \"\";\n\n            var pt = 0;\n            var txt = \"\";\n\n            // Draw gridlines\n            this.ctx[this.layers.GRID].strokeStyle = GridColor;\n            this.ctx[this.layers.GRID].lineWidth = GridThickness;\n            for (var i = args.stepStart; i <= args.stepLimit; i += Math.abs(args.axisinfo.gridline * args.axisinfo.scale)) {\n                this.ctx[this.layers.GRID].beginPath();\n                if (args.axisY0 && args.axisY1) {\n                    this.ctx[this.layers.GRID].moveTo(i, args.axisY0);\n                    this.ctx[this.layers.GRID].lineTo(i, args.axisY1);\n                } else if (args.axisX0 && args.axisX1) {\n                    this.ctx[this.layers.GRID].moveTo(args.axisX0, i);\n                    this.ctx[this.layers.GRID].lineTo(args.axisX1, i);\n                }\n                this.ctx[this.layers.GRID].stroke();\n            }\n            // Draw minor ticks\n            this.ctx[this.layers.FRAME].strokeStyle = TickColor;\n            this.ctx[this.layers.FRAME].lineWidth = TickThickness;\n            for (var _i = args.stepStart; _i <= args.stepLimit; _i += Math.abs(args.axisinfo.minortick * args.axisinfo.scale)) {\n                this.ctx[this.layers.FRAME].beginPath();\n                if (args.axisY0 && args.axisY1) {\n                    this.ctx[this.layers.FRAME].moveTo(_i, args.axisY0);\n                    this.ctx[this.layers.FRAME].lineTo(_i, args.axisY0 + args.tickSign * MinorAxisTickLength);\n                } else if (args.axisX0 && args.axisX1) {\n                    this.ctx[this.layers.FRAME].moveTo(args.axisX0, _i);\n                    this.ctx[this.layers.FRAME].lineTo(args.axisX0 + args.tickSign * MinorAxisTickLength, _i);\n                }\n                this.ctx[this.layers.FRAME].stroke();\n            }\n            // Draw major ticks and numbers\n            for (var _i2 = args.stepStart; _i2 <= args.stepLimit; _i2 += Math.abs(args.axisinfo.majortick * args.axisinfo.scale)) {\n                this.ctx[this.layers.FRAME].beginPath();\n                this.ctx[this.layers.FRAME].strokeStyle = TickColor;\n                if (args.axisY0 && args.axisY1) {\n                    this.ctx[this.layers.FRAME].moveTo(_i2, args.axisY0);\n                    this.ctx[this.layers.FRAME].lineTo(_i2, args.axisY0 + args.tickSign * MajorAxisTickLength);\n                    txt = (0, _skyHelpers.roundTo)(args.axisinfo.RawToCal(_i2), LabelDigits);\n                    pt = new _Point.Point({ rawx: _i2, rawy: args.axisY0 + args.numberOffset, graphinfo: this.graphinfo });\n                } else if (args.axisX0 && args.axisX1) {\n                    this.ctx[this.layers.FRAME].moveTo(args.axisX0, _i2);\n                    this.ctx[this.layers.FRAME].lineTo(args.axisX0 + args.tickSign * MajorAxisTickLength, _i2);\n                    txt = (0, _skyHelpers.roundTo)(args.axisinfo.RawToCal(_i2), LabelDigits);\n                    pt = new _Point.Point({ rawx: args.axisX0 + args.numberOffset, rawy: _i2, graphinfo: this.graphinfo });\n                }\n                this.ctx[this.layers.FRAME].stroke();\n\n                new _Text.Text({\n                    \"text\": txt,\n                    \"align\": \"center\",\n                    \"color\": TextColor,\n                    \"font\": TextFont,\n                    \"fontsize\": TextFontSize,\n                    \"fontstyle\": TextFontStyle,\n                    \"position\": pt\n                }).draw(this.ctx[this.layers.FRAME]);\n            }\n\n            // Draw label\n            new _Text.Text({\n                \"text\": args.axisinfo.label,\n                \"align\": \"center\",\n                \"color\": TextColor,\n                \"font\": TextFont,\n                \"fontsize\": TextFontSize,\n                \"fontstyle\": TextFontStyle,\n                \"position\": new _Point.Point({ rawx: args.labelX, rawy: args.labelY, graphinfo: this.graphinfo }),\n                graphinfo: this.graphinfo,\n                rotate: args.labelrotate\n            }).draw(this.ctx[this.layers.FRAME]);\n        }\n        /**\r\n            Checks each type of element (point, line, etc) and removes the oldest member(s) if more than the maximum exist\r\n        */\n\n    }, {\n        key: \"trimLists\",\n        value: function trimLists() {\n            var quota = {};\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = Object.keys(this.max)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var type = _step5.value;\n\n                    quota[type] = this.max[type];\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            for (var i = this.finished.length - 1; i >= 0; i--) {\n                var obj = this.finished[i];\n                if (obj.answer) {\n                    if (obj instanceof _Point.Point) {\n                        if (quota[\"point\"] != undefined) {\n                            if (quota[\"point\"] > 0) {\n                                quota[\"point\"] -= 1;\n                            } else {\n                                this.finished.splice(this.finished.indexOf(obj), 1);\n                            }\n                        }\n                    } else if (obj instanceof _Line.Line) {\n                        if (quota[\"line\"] != undefined) {\n                            if (quota[\"line\"] > 0) {\n                                quota[\"line\"] -= 1;\n                            } else {\n                                this.finished.splice(this.finished.indexOf(obj), 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\r\n            Finds a point in the list of drawn objects by its {@link Point#ID}\r\n            @return {Point}\r\n        */\n\n    }, {\n        key: \"getPointByID\",\n        value: function getPointByID(ID) {\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = this.finished[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var pt = _step6.value;\n\n                    if (pt instanceof _Point.Point) {\n                        if (pt.ID === ID) {\n                            return pt;\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n        }\n        /**\r\n            Deletes a point in the list of drawn objects by its {@link Point#ID}\r\n        */\n\n    }, {\n        key: \"deletePointByID\",\n        value: function deletePointByID(ID) {\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n                for (var _iterator7 = this.finished[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                    var pt = _step7.value;\n\n                    if (pt instanceof _Point.Point) {\n                        if (pt.ID === ID) {\n                            this.finished.splice(this.finished.indexOf(pt), 1);\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError7 = true;\n                _iteratorError7 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                        _iterator7.return();\n                    }\n                } finally {\n                    if (_didIteratorError7) {\n                        throw _iteratorError7;\n                    }\n                }\n            }\n        }\n        /**\r\n            Displays cursor data next to the mouse cursor\r\n            @param {Point} cursorpt Location of the cursor\r\n            @param {object} cursordata How the cursor data should look\r\n            @param {string} [cursordata.color=\"black\"] What color the text is written in\r\n            @param {string} [cursordata.font=\"sans-serif\"] What font the text is written in\r\n            @param {string} [cursordata.fontsize=\"16\"] What size the text is written in (in px)\r\n            @param {string} [cursordata.fontstyle=\"bold\"] What style the text is written in\r\n            @param {string} cursordata.format Format of the string to display (use ~x~, ~x2~, ~y~, or ~y2~ for relevant coordinate)\r\n            @param {object} cursordata.digits How many digits to round to for each axis. If using an axis in cursordata.format, it must have a number of digits set.\r\n            @param {int} cursordata.digits.x\r\n            @param {int} cursordata.digits.x2\r\n            @param {int} cursordata.digits.y\r\n            @param {int} cursordata.digits.y2\r\n            @param {number} [cursordata.distance=25] Distance from the center of the cursor to the text display\r\n        */\n\n    }, {\n        key: \"drawCursor\",\n        value: function drawCursor(cursorpt, cursordata) {\n            // Bound cursor within graph\n            if (cursorpt.x) {\n                cursorpt.x = (0, _skyHelpers.constrain)(cursorpt.x, this.graphinfo.x.min, this.graphinfo.x.max);\n            }\n            if (cursorpt.y) {\n                cursorpt.y = (0, _skyHelpers.constrain)(cursorpt.y, this.graphinfo.y.min, this.graphinfo.y.max);\n            }\n            if (cursorpt.x2) {\n                cursorpt.x2 = (0, _skyHelpers.constrain)(cursorpt.x2, this.graphinfo.x2.min, this.graphinfo.x2.max);\n            }\n            if (cursorpt.y2) {\n                cursorpt.y2 = (0, _skyHelpers.constrain)(cursorpt.y2, this.graphinfo.y2.min, this.graphinfo.y2.max);\n            }\n            cursorpt.generateRawFromCal();\n\n            // Align text around cursor\n            var midx = this.graphinfo.graphwidth / 2 + this.graphinfo.padding.left;\n            var midy = this.graphinfo.graphheight / 2 + this.graphinfo.padding.top;\n            var theta = (0, _skyHelpers.getAngle)(cursorpt.rawx, cursorpt.rawy, midx, midy);\n            var cursoralign = 0;\n            var cursorvalign = 0.5;\n            if (theta >= Math.PI) {\n                cursoralign = -theta / Math.PI + 2;\n            } else {\n                cursoralign = theta / Math.PI;\n            }\n            // Default cursor value\n            cursordata.distance = cursordata.distance ? cursordata.distance : 25;\n\n            // Calculate text display location\n            var cursorrawx = cursorpt.rawx;\n            var cursorrawy = cursorpt.rawy;\n            var edgemargin = 5;\n            if (cursorrawx <= this.graphinfo.graphleft) {\n                cursoralign = 0;\n                cursorrawx = this.graphinfo.graphleft + edgemargin;\n            } else if (cursorrawx >= this.graphinfo.graphright) {\n                cursoralign = 1;\n                cursorrawx = this.graphinfo.graphright - edgemargin;\n            } else {\n                cursorrawx += cursordata.distance * Math.cos(theta) / Math.sqrt(Math.abs(Math.cos(theta)));\n            }\n            if (cursorrawy <= this.graphinfo.graphtop) {\n                cursorvalign = 1;\n                cursorrawy = this.graphinfo.graphtop + edgemargin;\n            } else if (cursorrawy >= this.graphinfo.graphbottom) {\n                cursorvalign = 0;\n                cursorrawy = this.graphinfo.graphbottom - edgemargin;\n            } else {\n                cursorrawy += cursordata.distance * Math.sin(theta) / Math.sqrt(Math.abs(Math.sin(theta)));\n            }\n\n            // Fill default arguments\n            var cursorcolor = \"black\";\n            if (cursordata.color != undefined) {\n                cursorcolor = cursordata.color;\n            }\n            var cursorfont = \"sans-serif\";\n            if (cursordata.font != undefined) {\n                cursorfont = cursordata.font;\n            }\n            var cursorfontsize = \"16\";\n            if (cursordata.fontsize != undefined) {\n                cursorfontsize = cursordata.fontsize;\n            }\n            var cursorfontstyle = \"bold\";\n            if (cursordata.fontstyle != undefined) {\n                cursorfontstyle = cursordata.fontstyle;\n            }\n            // Generate text based on cursordata format\n            var content = cursordata.format;\n            if (this.graphinfo.x != undefined) {\n                content = content.replace(SPVAR + \"x\" + SPVAR, cursorpt.x.toFixed(this.cursor.digits.x));\n            }\n            if (this.graphinfo.y != undefined) {\n                content = content.replace(SPVAR + \"y\" + SPVAR, cursorpt.y.toFixed(this.cursor.digits.y));\n            }\n            if (this.graphinfo.x2 != undefined) {\n                content = content.replace(SPVAR + \"x2\" + SPVAR, cursorpt.x2.toFixed(this.cursor.digits.x2));\n            }\n            if (this.graphinfo.y2 != undefined) {\n                content = content.replace(SPVAR + \"y2\" + SPVAR, cursorpt.y2.toFixed(this.cursor.digits.y2));\n            }\n\n            // Draw text\n            var cp = new _Point.Point({\n                \"rawx\": cursorrawx,\n                \"rawy\": cursorrawy,\n                \"graphinfo\": cursorpt.graphinfo,\n                \"show\": false,\n                \"label\": {\n                    \"text\": content,\n                    \"color\": cursorcolor,\n                    \"font\": cursorfont,\n                    \"fontsize\": cursorfontsize,\n                    \"fontstyle\": cursorfontstyle,\n                    \"align\": cursoralign,\n                    \"valign\": cursorvalign } });\n            this.draw(cp);\n            //this.draw(new Text());\n        }\n    }, {\n        key: \"grabElement\",\n        value: function grabElement(pt) {\n            var grabindex = -1;\n            var grabdist = 99999;\n            // Check which object is being picked up\n            for (var i in this.finished) {\n                if (this.finished[i] instanceof _Point.Point) {\n                    // Check if movable\n                    if (this.finished[i].movex || this.finished[i].movey) {\n                        // Check if in grabbing distance\n                        var d = (0, _skyHelpers.getDist)(pt, this.finished[i], \"raw\");\n                        if (d <= this.grabradius) {\n                            if (d < grabdist) {\n                                grabindex = i;\n                                grabdist = d;\n                            }\n                        }\n                    }\n                } else if (this.finished[i] instanceof _Line.Line) {\n                    for (var j = 1; j < this.finished[i].points.length; j++) {\n                        var pt1 = this.finished[i].points[j];\n                        var pt2 = this.finished[i].points[j - 1];\n                        // If either point is immovable, line isn't movable\n                        if (!pt1.movex && !pt1.movey || !pt2.movex && !pt2.movey) {\n                            // If any point is immobile, the line cannot be moved\n                            break;\n                        }\n                        // Shrink grabbing range for line (otherwise assume grabbing a point on either end)\n                        var minx = Math.min(pt1.rawx, pt2.rawx) + this.grabradius;\n                        var maxx = Math.max(pt1.rawx, pt2.rawx) - this.grabradius;\n                        // Check if clicked x is between bounds\n                        if (pt.rawx > minx && pt.rawx < maxx) {\n                            var ytarget = (pt.rawx - pt1.rawx) * (pt2.rawy - pt1.rawy) / (pt2.rawx - pt1.rawx) + pt1.rawy;\n                            var _d = Math.abs(pt.rawy - ytarget);\n                            // Check if in grabbing range of the line\n                            if (_d <= this.grabradius) {\n                                // Check if this is the closest object\n                                if (_d < grabdist) {\n                                    grabindex = i;\n                                    grabdist = _d;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            // If an element was clicked on, pick it up\n            if (grabindex > -1) {\n                this.grabpoint = pt;\n                this.held = this.finished[grabindex];\n                this.finished.splice(grabindex, 1);\n                if (this.held instanceof _Line.Line) {\n                    this.origins = {};\n                    var _iteratorNormalCompletion8 = true;\n                    var _didIteratorError8 = false;\n                    var _iteratorError8 = undefined;\n\n                    try {\n                        for (var _iterator8 = this.held.points[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                            var p = _step8.value;\n\n                            this.origins[p.ID] = new _Point.Point(p.data());\n                            this.deletePointByID(p.ID);\n                        }\n                    } catch (err) {\n                        _didIteratorError8 = true;\n                        _iteratorError8 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                                _iterator8.return();\n                            }\n                        } finally {\n                            if (_didIteratorError8) {\n                                throw _iteratorError8;\n                            }\n                        }\n                    }\n                }\n                // Grabbed something\n                return true;\n            }\n            // Didn't grab anything\n            return false;\n        }\n    }, {\n        key: \"dragElement\",\n        value: function dragElement(pt) {\n            if (this.held instanceof _Point.Point) {\n                // Copy current location data to point\n                if (this.held.movex) {\n                    this.held.rawx = (0, _skyHelpers.constrain)(pt.rawx, this.graphinfo.padding.left, this.graphinfo.padding.left + this.graphinfo.graphwidth);\n                }\n                if (this.held.movey) {\n                    this.held.rawy = (0, _skyHelpers.constrain)(pt.rawy, this.graphinfo.padding.top, this.graphinfo.padding.top + this.graphinfo.graphheight);\n                }\n                // Calculated calibrated positions from new raw position\n                this.held.generateCalFromRaw();\n                // Show held point\n                this.draw(this.held);\n            } else if (this.held instanceof _Line.Line) {\n                // Update location data\n                var rawdx = pt.rawx - this.grabpoint.rawx;\n                var caldx = pt.x - this.grabpoint.x;\n                var rawdy = pt.rawy - this.grabpoint.rawy;\n                var caldy = pt.y - this.grabpoint.y;\n                var _iteratorNormalCompletion9 = true;\n                var _didIteratorError9 = false;\n                var _iteratorError9 = undefined;\n\n                try {\n                    for (var _iterator9 = this.held.points[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                        var p = _step9.value;\n\n                        if (p.movex) {\n                            p.rawx = (0, _skyHelpers.constrain)(this.origins[p.ID].rawx + rawdx, this.graphinfo.padding.left, this.graphinfo.padding.left + this.graphinfo.graphwidth);\n                        }\n                        if (p.movey) {\n                            p.rawy = (0, _skyHelpers.constrain)(this.origins[p.ID].rawy + rawdy, this.graphinfo.padding.top, this.graphinfo.padding.top + this.graphinfo.graphheight);\n                        }\n                        p.generateCalFromRaw();\n                        // Show points\n                        if (p.show) {\n                            this.draw(p);\n                        }\n                    }\n                    // Show held line\n                } catch (err) {\n                    _didIteratorError9 = true;\n                    _iteratorError9 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                            _iterator9.return();\n                        }\n                    } finally {\n                        if (_didIteratorError9) {\n                            throw _iteratorError9;\n                        }\n                    }\n                }\n\n                this.draw(this.held);\n            }\n        }\n    }, {\n        key: \"dropElement\",\n        value: function dropElement(pt) {\n            if (this.held instanceof _Point.Point) {\n                // Copy current location data to point\n                if (this.held.movex) {\n                    this.held.rawx = (0, _skyHelpers.constrain)(pt.rawx, this.graphinfo.padding.left, this.graphinfo.padding.left + this.graphinfo.graphwidth);\n                }\n                if (this.held.movey) {\n                    this.held.rawy = (0, _skyHelpers.constrain)(pt.rawy, this.graphinfo.padding.top, this.graphinfo.padding.top + this.graphinfo.graphheight);\n                }\n                // Calculated calibrated positions from new raw position\n                this.held.generateCalFromRaw();\n                // Add point to finished list\n                this.finished.push(this.held);\n            } else if (this.held instanceof _Line.Line) {\n                var rawdx = pt.rawx - this.grabpoint.rawx;\n                var caldx = pt.x - this.grabpoint.x;\n                var rawdy = pt.rawy - this.grabpoint.rawy;\n                var caldy = pt.y - this.grabpoint.y;\n                var _iteratorNormalCompletion10 = true;\n                var _didIteratorError10 = false;\n                var _iteratorError10 = undefined;\n\n                try {\n                    for (var _iterator10 = this.held.points[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                        var p = _step10.value;\n\n                        if (p.movex) {\n                            p.rawx = (0, _skyHelpers.constrain)(this.origins[p.ID].rawx + rawdx, this.graphinfo.padding.left, this.graphinfo.padding.left + this.graphinfo.graphwidth);\n                        }\n                        if (p.movey) {\n                            p.rawy = (0, _skyHelpers.constrain)(this.origins[p.ID].rawy + rawdy, this.graphinfo.padding.top, this.graphinfo.padding.top + this.graphinfo.graphheight);\n                        }\n                        p.generateCalFromRaw();\n                        // Show points\n                        if (p.show) {\n                            this.finished.push(p);\n                        }\n                    }\n                    // Add line to finished list\n                } catch (err) {\n                    _didIteratorError10 = true;\n                    _iteratorError10 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                            _iterator10.return();\n                        }\n                    } finally {\n                        if (_didIteratorError10) {\n                            throw _iteratorError10;\n                        }\n                    }\n                }\n\n                this.finished.push(this.held);\n                this.origins = undefined;\n                this.grabpoint = undefined;\n            }\n            // Reset holding\n            this.held = undefined;\n        }\n        /**\r\n            Whenever the mouse is moved over the canvas, update the dynamic layer.\r\n        */\n\n    }, {\n        key: \"mouseMove\",\n        value: function mouseMove(e) {\n            // Get location of event\n\n            var pt = this.getMousePoint(e);\n            this.update();\n\n            // Draw cursor\n            if (this.cursor != undefined) {\n                var cursorpt = new _Point.Point(pt.data());\n                if (this.held) {\n                    if (this.held.altcursor) {\n                        this.drawCursor(cursorpt, this.held.altcursor);\n                    } else {\n                        this.drawCursor(cursorpt, this.cursor);\n                    }\n                } else {\n                    this.drawCursor(cursorpt, this.cursor);\n                }\n            }\n            // If moving objects\n            if (this.mode === \"move\") {\n                // Drag held object\n                if (this.held) {\n                    this.dragElement(pt);\n                }\n                // If drawing\n            } else if (this.drawing) {\n                if (this.mode === \"point\") {\n                    this.draw(pt);\n                } else if (this.mode === \"line\") {\n                    this.draw(new _Line.Line({ \"points\": [this.pt, pt] }));\n                } else if (this.mode === \"calibrate\") {\n                    this.draw(new _Line.Line({ \"points\": [this.pt, pt] }));\n                }\n            }\n        }\n        /**\r\n            Whenever the mouse is released over the canvas\r\n        */\n\n    }, {\n        key: \"mouseUp\",\n        value: function mouseUp(e) {\n            // Get location of event\n            var pt = this.getMousePoint(e);\n            if (this.mode === \"move\") {\n                if (this.held) {\n                    this.dropElement(pt);\n                }\n            } else if (this.mode === \"draw\") {\n                this.drawing = false;\n                if (this.mode === \"point\") {\n                    this.finished.push(pt);\n                } else if (this.mode === \"line\") {\n                    this.finished.push(new _Line.Line({ \"points\": [this.pt, pt] }));\n                } else if (this.mode === \"calibrate\") {\n                    // calibration routine\n                    this.finished.push(new _Line.Line({ \"points\": [this.pt, pt] }));\n                    var x1 = document.getElementById(this.x1).value;\n                    var y1 = document.getElementById(this.y1).value;\n                    var x2 = document.getElementById(this.x2).value;\n                    var y2 = document.getElementById(this.y2).value;\n                    var str = \"let calibration = new Line({\\\"points\\\":[new Point({\\\"rawx\\\":\" + this.pt.rawx + \", \\\"rawy\\\":\" + this.pt.rawy + \", \\\"x\\\":\" + x1 + \", \\\"y\\\":\" + y1 + \"})\";\n                    str += \", new Point({\\\"rawx\\\":\" + pt.rawx + \", \\\"rawy\\\":\" + pt.rawy + \", \\\"x\\\":\" + x2 + \", \\\"y\\\":\" + y2 + \"})]});\";\n                    console.log(\"Copy and paste the line between the bars to use this calibration:\");\n                    console.log(\"-----\");\n                    console.log(str);\n                    console.log(\"-----\");\n                }\n            }\n        }\n        /**\r\n            Whenever the mouse is clicked on the canvas object\r\n        */\n\n    }, {\n        key: \"mouseDown\",\n        value: function mouseDown(e) {\n            // Get location of event\n            var pt = this.getMousePoint(e);\n            if (this.mode == \"move\") {\n                // Check if an element was grabbed\n                if (this.grabElement(pt)) {\n                    this.update();\n                    this.draw(this.held);\n                }\n            } else if (this.mode == \"draw\") {\n                this.pt1 = pt;\n                this.drawing = true;\n            }\n        }\n        /**\r\n            Handle key-press events<br>\r\n            Must be forwarded from {@link ProblemController}\r\n        */\n\n    }, {\n        key: \"keyPress\",\n        value: function keyPress(key) {\n            this.drawing = false;\n            this.calibrating = false;\n            if (key === \"p\") {\n                this.mode = \"point\";\n            } else if (key === \"l\") {\n                this.mode = \"line\";\n            }\n            this.update();\n        }\n    }]);\n\n    return GraphCanvas;\n}();\n\n//# sourceURL=webpack:///./src/GraphCanvas.js?");

/***/ }),

/***/ "./src/GraphCanvasController.js":
/*!**************************************!*\
  !*** ./src/GraphCanvasController.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.GraphCanvasController = exports.LAYERS = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DOM = __webpack_require__(/*! ./DOM.js */ \"./src/DOM.js\");\n\nvar _Text = __webpack_require__(/*! ./Text.js */ \"./src/Text.js\");\n\nvar _Line = __webpack_require__(/*! ./Line.js */ \"./src/Line.js\");\n\nvar _Point = __webpack_require__(/*! ./Point.js */ \"./src/Point.js\");\n\nvar _ZCanvas = __webpack_require__(/*! ./ZCanvas.js */ \"./src/ZCanvas.js\");\n\nvar _skyHelpers = __webpack_require__(/*! ./sky-helpers.js */ \"./src/sky-helpers.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar VAR = \"@\";\nvar GRABRADIUS = 10;\nvar SPVAR = \"~\";\n\n// Layer information\nvar LAYERS = exports.LAYERS = {\n    \"GRID\": 0,\n    \"UNDER\": 1,\n    \"FRAME\": 2,\n    \"OVER\": 3,\n    \"CURSOR\": 4\n};\n\n/**\r\n    Controller class for HTML canvas objects<br>\r\n    Uses two overlaid canvases for background and foreground drawing.\r\n*/\n\nvar GraphCanvasController = exports.GraphCanvasController = function () {\n    /**\r\n        @param {int} index Index to identify canvas\r\n        @param {object} args Object of input arguments\r\n        @param {int} args.layers Number of layers\r\n        @param {int} args.width Width of canvases\r\n        @param {int} args.height Height of canvases\r\n        @param {string} args.containerid ID of container element\r\n        @param {string} args.containerclass class of container element\r\n        @param {string} args.canvasidprefix ID of each canvas, postpended by its layer number\r\n        @param {string} args.canvasclass Classes added to each canvas\r\n        @param {object} args.cursor Object describing how the cursor should look (used as cursordata for {@link GraphCanvasController#drawCursor})\r\n        @param {string} args.mode Valid modes are \"none\", \"view\", \"move\"\r\n        @param {object} args.answercount Maximum number of elements to allow on graph\r\n        @param {int} args.answercount.point\r\n        @param {int} args.answercount.line\r\n        @param {object} args.default Default elements that exist on graph\r\n        @param {list} args.default.point\r\n        @param {list} args.default.line\r\n    */\n    function GraphCanvasController(index, args) {\n        var _this = this;\n\n        _classCallCheck(this, GraphCanvasController);\n\n        // Pull in arguments\n        this.mode = args.mode;\n        this.graphinfo = args.graphinfo;\n        this.cursor = args.cursor;\n\n        // Unique number for this canvas\n        this.index = index;\n        var re = new RegExp(VAR + \"id\" + VAR, \"g\");\n\n        // Retrieve DOM elements\n        var zc = new _ZCanvas.ZCanvas({\n            \"layers\": Object.keys(LAYERS).length,\n            \"width\": this.graphinfo.width,\n            \"height\": this.graphinfo.height,\n            \"containerid\": \"canvasarea--\" + index,\n            \"containerclass\": _DOM.DOM.canvasdivclass,\n            \"canvasidprefix\": \"canvas--\",\n            \"canvasclass\": _DOM.DOM.canvasclass\n        });\n        this.canvas = zc.canvas;\n        this.ctx = zc.ctx;\n\n        // Set up canvas size\n        this.height = this.graphinfo.height;\n        this.width = this.graphinfo.width;\n\n        // Draw graph layout\n        this.drawGraph();\n\n        // State variables\n        this.drawing = false; /* True when not finished drawing */\n\n        // Constants\n        this.grabradius = GRABRADIUS;\n\n        this.max = [];\n        this.finished = [];\n        // Set max elements of each type, if specified\n        if (args.answercount != undefined) {\n            this.max = args.answercount;\n        }\n        // Set default elements of each type, if specified\n        if (args.default != undefined) {\n            this.default = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = Object.keys(args.default)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var type = _step.value;\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = args.default[type][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var d = _step2.value;\n\n                            this.finished.push(this.dataToElement(type, d));\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n\n        // Set up mouse events\n        this.canvas[\"top\"].addEventListener(\"mousemove\", function (e) {\n            return _this.mouseMove(e);\n        });\n        this.canvas[\"top\"].addEventListener(\"mousedown\", function (e) {\n            return _this.mouseDown(e);\n        });\n        this.canvas[\"top\"].addEventListener(\"mouseup\", function (e) {\n            return _this.mouseUp(e);\n        });\n\n        // Initialize\n        this.update();\n    }\n\n    /**\r\n        Clears the foreground canvas\r\n    */\n\n\n    _createClass(GraphCanvasController, [{\n        key: \"clear\",\n        value: function clear() {\n            //this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\n            // Hacky workaround\n            this.canvas[LAYERS.UNDER].width = this.canvas[LAYERS.UNDER].width;\n            this.canvas[LAYERS.OVER].width = this.canvas[LAYERS.OVER].width;\n            this.canvas[LAYERS.CURSOR].width = this.canvas[LAYERS.CURSOR].width;\n        }\n\n        /**\r\n            Updates the canvas to its current state\r\n        */\n\n    }, {\n        key: \"update\",\n        value: function update() {\n            this.clear();\n            // Remove objects if over limits\n            if (this.mode != \"view\") {\n                this.trimLists();\n            }\n            // Draw lines\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.finished[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var obj = _step3.value;\n\n                    if (obj instanceof _Line.Line) {\n                        this.draw(obj);\n                    }\n                }\n                // Draw points\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = this.finished[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var _obj = _step4.value;\n\n                    if (_obj instanceof _Point.Point) {\n                        this.draw(_obj);\n                    }\n                }\n                // Draw text\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = this.finished[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var _obj2 = _step5.value;\n\n                    if (_obj2 instanceof _Text.Text) {\n                        this.draw(_obj2);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n        }\n        /**\r\n            Creates geometric class object from input data\r\n            @param {string} type \"point\", \"line\", or \"text\"\r\n            @param {object} data Object of input arguments for object\r\n            @return {Point|Line|Text} An instance of the chosen class\r\n        */\n\n    }, {\n        key: \"dataToElement\",\n        value: function dataToElement(type, data) {\n            // Append calibration data\n            data.graphinfo = this.graphinfo;\n            // Create appropriate object\n            if (type === \"point\") {\n                return new _Point.Point(data);\n            } else if (type === \"line\") {\n                var ptlist = [];\n                if (data.points) {\n                    // line constructed from list of points\n                    var _iteratorNormalCompletion6 = true;\n                    var _didIteratorError6 = false;\n                    var _iteratorError6 = undefined;\n\n                    try {\n                        for (var _iterator6 = data.points[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                            var ptdata = _step6.value;\n\n                            ptdata.graphinfo = this.graphinfo;\n                            var pt = new _Point.Point(ptdata);\n                            ptlist.push(pt);\n                            if (pt.show) {\n                                this.finished.push(pt);\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError6 = true;\n                        _iteratorError6 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                _iterator6.return();\n                            }\n                        } finally {\n                            if (_didIteratorError6) {\n                                throw _iteratorError6;\n                            }\n                        }\n                    }\n\n                    data.points = ptlist;\n                } else if (data.equation) {\n                    // line constructed from equation\n                    var ind = data.independent;\n                    var dep = data.dependent;\n                    var di = (ind.max - ind.min) / (data.steps - 1);\n                    // Replace independent variable with value\n                    var re = new RegExp(\"\" + SPVAR + data.independent.symbol + SPVAR, \"g\");\n\n                    // Calculate points along line\n                    var i = ind.min;\n                    while (i <= ind.max) {\n                        var _ptdata = {};\n                        _ptdata[ind.symbol] = i;\n                        // Evaluate expression (trusted code provided by the question-creator)\n                        _ptdata[dep.symbol] = (0, _skyHelpers.evalWithContext)(data.equation.replace(re, i));\n                        _ptdata[\"graphinfo\"] = this.graphinfo;\n                        if (data.showpoints) {\n                            _ptdata.show = true;\n                        } else {\n                            _ptdata.show = false;\n                        }\n                        var _pt = new _Point.Point(_ptdata);\n                        ptlist.push(_pt);\n                        if (_pt.show) {\n                            this.finished.push(_pt);\n                        }\n\n                        i += di;\n                    }\n                    if (data.label) {\n                        // Calculate y position\n                        data.label.dependent = (0, _skyHelpers.evalWithContext)(data.equation.replace(re, data.label.independent));\n                        // Calculate slope\n                        var nextpt = (0, _skyHelpers.evalWithContext)(data.equation.replace(re, data.label.independent + di));\n                        var dy = nextpt - data.label.dependent;\n                        var slope = Math.atan(dy * this.graphinfo.y.scale / (di * this.graphinfo.x.scale));\n                        data.label.rotate = 180 / Math.PI * slope;\n                        // Adjust for offset\n                        data.label.independent += data.label.indoffset;\n                        data.label.dependent += data.label.depoffset;\n                    }\n                    data.points = ptlist;\n                }\n                return new _Line.Line(data);\n            } else if (type === \"text\") {\n                data.position.graphinfo = this.graphinfo;\n                return new _Text.Text(data);\n            }\n        }\n        /**\r\n            @param {event} e Mouse event\r\n            @return {Point} Point object at the current location of the mouse cursor\r\n        */\n\n    }, {\n        key: \"getMousePoint\",\n        value: function getMousePoint(e) {\n            return new _Point.Point({ \"rawx\": e.pageX - this.canvas[LAYERS.CURSOR].offsetParent.offsetLeft,\n                \"rawy\": e.pageY - this.canvas[LAYERS.CURSOR].offsetParent.offsetTop,\n                \"graphinfo\": this.graphinfo });\n        }\n        /**\r\n            Draws an element to the foreground canvas<br>\r\n            To be replaced with Object.draw() calls\r\n            @param {Point|Line|Text} element QuestionElement to be drawn\r\n        */\n\n    }, {\n        key: \"draw\",\n        value: function draw(element) {\n            var layer = undefined;\n            if (element.layer) {\n                layer = element.layer;\n            }\n            this.ctx[element.layer];\n            this.ctx[layer].save();\n            element.draw(this.ctx[layer]);\n            this.ctx[layer].restore();\n        }\n        /**\r\n            Draws the background of the graph (background colors, axes, labels)<br>\r\n            Needs serious revision\r\n        */\n\n    }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n            // Border region\n            this.ctx[LAYERS.FRAME].fillStyle = this.graphinfo.axesbackground;\n            this.ctx[LAYERS.FRAME].fillRect(0, 0, this.graphinfo.width, this.graphinfo.graphtop);\n            this.ctx[LAYERS.FRAME].fillRect(0, 0, this.graphinfo.graphleft, this.graphinfo.height);\n            this.ctx[LAYERS.FRAME].fillRect(this.graphinfo.graphright, 0, this.graphinfo.width, this.graphinfo.height);\n            this.ctx[LAYERS.FRAME].fillRect(0, this.graphinfo.graphbottom, this.graphinfo.width, this.graphinfo.height);\n\n            // Graph region\n            this.ctx[LAYERS.GRID].fillStyle = this.graphinfo.graphbackground;\n            this.ctx[LAYERS.GRID].fillRect(this.graphinfo.padding.left, this.graphinfo.padding.top, this.graphinfo.graphwidth, this.graphinfo.graphheight);\n\n            // TODO use text measuring to place label text\n\n            // X axis\n            if (this.graphinfo.x != undefined) {\n                this.drawAxis({\n                    axisinfo: this.graphinfo.x,\n                    stepStart: this.graphinfo.padding.left,\n                    stepLimit: this.graphinfo.width - this.graphinfo.padding.right,\n                    axisY0: this.graphinfo.height - this.graphinfo.padding.bottom,\n                    axisY1: this.graphinfo.padding.top,\n                    tickSign: -1,\n                    numberOffset: 10,\n                    labelX: this.graphinfo.graphwidth / 2 + this.graphinfo.padding.left,\n                    labelY: this.graphinfo.height - this.graphinfo.padding.bottom + 40,\n                    labelrotate: 0\n                });\n            }\n            // Y axis\n            if (this.graphinfo.y != undefined) {\n                this.drawAxis({\n                    axisinfo: this.graphinfo.y,\n                    stepStart: this.graphinfo.padding.top,\n                    stepLimit: this.height - this.graphinfo.padding.bottom,\n                    axisX0: this.graphinfo.padding.left,\n                    axisX1: this.graphinfo.padding.left + this.graphinfo.graphwidth,\n                    tickSign: 1,\n                    numberOffset: -20,\n                    labelX: this.graphinfo.padding.left - 50,\n                    labelY: this.graphinfo.graphheight / 2 + this.graphinfo.padding.top,\n                    labelrotate: -90\n                });\n            }\n            // X2 axis\n            if (this.graphinfo.x2 != undefined) {\n                this.drawAxis({\n                    axisinfo: this.graphinfo.x2,\n                    stepStart: this.graphinfo.padding.left,\n                    stepLimit: this.graphinfo.width - this.graphinfo.padding.right,\n                    axisY0: this.graphinfo.padding.top,\n                    axisY1: this.graphinfo.height - this.graphinfo.padding.bottom,\n                    tickSign: 1,\n                    numberOffset: -11,\n                    labelX: this.graphinfo.graphwidth / 2 + this.graphinfo.padding.left,\n                    labelY: this.graphinfo.padding.top - 40,\n                    labelrotate: 0\n                });\n            }\n            // Y2 axis\n            if (this.graphinfo.y2 != undefined) {\n                this.drawAxis({\n                    // TODO test values to make sure they display well\n                    axisinfo: this.graphinfo.y2,\n                    stepStart: this.graphinfo.padding.top,\n                    stepLimit: this.height - this.graphinfo.padding.bottom,\n                    axisX0: this.graphinfo.padding.left,\n                    axisX1: this.graphinfo.padding.left + this.graphinfo.graphwidth,\n                    tickSign: -1,\n                    numberOffset: 20,\n                    labelX: this.graphinfo.padding.left + this.graphinfo.graphwidth + 40,\n                    labelY: this.graphinfo.graphheight / 2 + this.graphinfo.padding.top,\n                    labelrotate: 90\n                });\n            }\n            // Bounding box\n            this.ctx[LAYERS.FRAME].rect(this.graphinfo.padding.left, this.graphinfo.padding.top, this.graphinfo.graphwidth, this.graphinfo.graphheight);\n            this.ctx[LAYERS.FRAME].strokeStyle = \"black\";\n            this.ctx[LAYERS.FRAME].lineWidth = 1;\n            this.ctx[LAYERS.FRAME].stroke();\n        }\n        /**\r\n            Abstract method to replace drawGraph\r\n        */\n\n    }, {\n        key: \"drawAxis\",\n        value: function drawAxis(args) {\n            // Constants\n            var MajorAxisTickLength = 10;\n            var MinorAxisTickLength = 5;\n            var LabelDigits = 3;\n            var LabelxDigits = LabelDigits;\n            var LabelyDigits = LabelDigits;\n            var Labelx2Digits = LabelDigits;\n            var Labely2Digits = LabelDigits;\n            var GridColor = \"lightgray\";\n            var GridThickness = 1;\n            var TickColor = \"gray\";\n            var TickThickness = 1;\n            var TextColor = \"black\";\n            var TextFont = \"sans-serif\";\n            var TextFontSize = 20;\n            var TextFontStyle = \"\";\n\n            var pt = 0;\n            var txt = \"\";\n\n            // Draw gridlines\n            this.ctx[LAYERS.GRID].strokeStyle = GridColor;\n            this.ctx[LAYERS.GRID].lineWidth = GridThickness;\n            for (var i = args.stepStart; i <= args.stepLimit; i += Math.abs(args.axisinfo.gridline * args.axisinfo.scale)) {\n                this.ctx[LAYERS.GRID].beginPath();\n                if (args.axisY0 && args.axisY1) {\n                    this.ctx[LAYERS.GRID].moveTo(i, args.axisY0);\n                    this.ctx[LAYERS.GRID].lineTo(i, args.axisY1);\n                } else if (args.axisX0 && args.axisX1) {\n                    this.ctx[LAYERS.GRID].moveTo(args.axisX0, i);\n                    this.ctx[LAYERS.GRID].lineTo(args.axisX1, i);\n                }\n                this.ctx[LAYERS.GRID].stroke();\n            }\n            // Draw minor ticks\n            this.ctx[LAYERS.FRAME].strokeStyle = TickColor;\n            this.ctx[LAYERS.FRAME].lineWidth = TickThickness;\n            for (var _i = args.stepStart; _i <= args.stepLimit; _i += Math.abs(args.axisinfo.minortick * args.axisinfo.scale)) {\n                this.ctx[LAYERS.FRAME].beginPath();\n                if (args.axisY0 && args.axisY1) {\n                    this.ctx[LAYERS.FRAME].moveTo(_i, args.axisY0);\n                    this.ctx[LAYERS.FRAME].lineTo(_i, args.axisY0 + args.tickSign * MinorAxisTickLength);\n                } else if (args.axisX0 && args.axisX1) {\n                    this.ctx[LAYERS.FRAME].moveTo(args.axisX0, _i);\n                    this.ctx[LAYERS.FRAME].lineTo(args.axisX0 + args.tickSign * MinorAxisTickLength, _i);\n                }\n                this.ctx[LAYERS.FRAME].stroke();\n            }\n            // Draw major ticks and numbers\n            for (var _i2 = args.stepStart; _i2 <= args.stepLimit; _i2 += Math.abs(args.axisinfo.majortick * args.axisinfo.scale)) {\n                this.ctx[LAYERS.FRAME].beginPath();\n                this.ctx[LAYERS.FRAME].strokeStyle = TickColor;\n                if (args.axisY0 && args.axisY1) {\n                    this.ctx[LAYERS.FRAME].moveTo(_i2, args.axisY0);\n                    this.ctx[LAYERS.FRAME].lineTo(_i2, args.axisY0 + args.tickSign * MajorAxisTickLength);\n                    txt = (0, _skyHelpers.roundTo)(args.axisinfo.RawToCal(_i2), LabelDigits);\n                    pt = new _Point.Point({ rawx: _i2, rawy: args.axisY0 + args.numberOffset, graphinfo: this.graphinfo });\n                } else if (args.axisX0 && args.axisX1) {\n                    this.ctx[LAYERS.FRAME].moveTo(args.axisX0, _i2);\n                    this.ctx[LAYERS.FRAME].lineTo(args.axisX0 + args.tickSign * MajorAxisTickLength, _i2);\n                    txt = (0, _skyHelpers.roundTo)(args.axisinfo.RawToCal(_i2), LabelDigits);\n                    pt = new _Point.Point({ rawx: args.axisX0 + args.numberOffset, rawy: _i2, graphinfo: this.graphinfo });\n                }\n                this.ctx[LAYERS.FRAME].stroke();\n\n                new _Text.Text({\n                    \"text\": txt,\n                    \"align\": \"center\",\n                    \"color\": TextColor,\n                    \"font\": TextFont,\n                    \"fontsize\": TextFontSize,\n                    \"fontstyle\": TextFontStyle,\n                    \"position\": pt\n                }).draw(this.ctx[LAYERS.FRAME]);\n            }\n\n            // Draw label\n            new _Text.Text({\n                \"text\": args.axisinfo.label,\n                \"align\": \"center\",\n                \"color\": TextColor,\n                \"font\": TextFont,\n                \"fontsize\": TextFontSize,\n                \"fontstyle\": TextFontStyle,\n                \"position\": new _Point.Point({ rawx: args.labelX, rawy: args.labelY, graphinfo: this.graphinfo }),\n                graphinfo: this.graphinfo,\n                rotate: args.labelrotate\n            }).draw(this.ctx[LAYERS.FRAME]);\n        }\n        /**\r\n            Checks each type of element (point, line, etc) and removes the oldest member(s) if more than the maximum exist\r\n        */\n\n    }, {\n        key: \"trimLists\",\n        value: function trimLists() {\n            var quota = {};\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n                for (var _iterator7 = Object.keys(this.max)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                    var type = _step7.value;\n\n                    quota[type] = this.max[type];\n                }\n            } catch (err) {\n                _didIteratorError7 = true;\n                _iteratorError7 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                        _iterator7.return();\n                    }\n                } finally {\n                    if (_didIteratorError7) {\n                        throw _iteratorError7;\n                    }\n                }\n            }\n\n            for (var i = this.finished.length - 1; i >= 0; i--) {\n                var obj = this.finished[i];\n                if (obj.answer) {\n                    if (obj instanceof _Point.Point) {\n                        if (quota[\"point\"] != undefined) {\n                            if (quota[\"point\"] > 0) {\n                                quota[\"point\"] -= 1;\n                            } else {\n                                this.finished.splice(this.finished.indexOf(obj), 1);\n                            }\n                        }\n                    } else if (obj instanceof _Line.Line) {\n                        if (quota[\"line\"] != undefined) {\n                            if (quota[\"line\"] > 0) {\n                                quota[\"line\"] -= 1;\n                            } else {\n                                this.finished.splice(this.finished.indexOf(obj), 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\r\n            Finds a point in the list of drawn objects by its {@link Point#ID}\r\n            @return {Point}\r\n        */\n\n    }, {\n        key: \"getPointByID\",\n        value: function getPointByID(ID) {\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n                for (var _iterator8 = this.finished[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                    var pt = _step8.value;\n\n                    if (pt instanceof _Point.Point) {\n                        if (pt.ID === ID) {\n                            return pt;\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError8 = true;\n                _iteratorError8 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                        _iterator8.return();\n                    }\n                } finally {\n                    if (_didIteratorError8) {\n                        throw _iteratorError8;\n                    }\n                }\n            }\n        }\n        /**\r\n            Deletes a point in the list of drawn objects by its {@link Point#ID}\r\n        */\n\n    }, {\n        key: \"deletePointByID\",\n        value: function deletePointByID(ID) {\n            var _iteratorNormalCompletion9 = true;\n            var _didIteratorError9 = false;\n            var _iteratorError9 = undefined;\n\n            try {\n                for (var _iterator9 = this.finished[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                    var pt = _step9.value;\n\n                    if (pt instanceof _Point.Point) {\n                        if (pt.ID === ID) {\n                            this.finished.splice(this.finished.indexOf(pt), 1);\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError9 = true;\n                _iteratorError9 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                        _iterator9.return();\n                    }\n                } finally {\n                    if (_didIteratorError9) {\n                        throw _iteratorError9;\n                    }\n                }\n            }\n        }\n        /**\r\n            Returns all finished elements on the graph marked as answers ({@link QuestionElement#answer})\r\n            @return {list} A list of {@link QuestionElement}s\r\n        */\n\n    }, {\n        key: \"getanswers\",\n        value: function getanswers() {\n            this.mode = \"view\";\n            this.update();\n            var answers = [];\n            var _iteratorNormalCompletion10 = true;\n            var _didIteratorError10 = false;\n            var _iteratorError10 = undefined;\n\n            try {\n                for (var _iterator10 = this.finished[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                    var element = _step10.value;\n\n                    if (element.answer) {\n                        answers.push(element);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError10 = true;\n                _iteratorError10 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                        _iterator10.return();\n                    }\n                } finally {\n                    if (_didIteratorError10) {\n                        throw _iteratorError10;\n                    }\n                }\n            }\n\n            return answers;\n        }\n        /**\r\n            Displays a set of elements as correct answers\r\n            @param {list} answers List of {@link QuestionElement}s\r\n        */\n\n    }, {\n        key: \"showanswers\",\n        value: function showanswers(answers) {\n            var answerselements = [];\n            // Convert answer data into geometric object elements\n            var _iteratorNormalCompletion11 = true;\n            var _didIteratorError11 = false;\n            var _iteratorError11 = undefined;\n\n            try {\n                for (var _iterator11 = Object.keys(answers)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                    var type = _step11.value;\n                    var _iteratorNormalCompletion13 = true;\n                    var _didIteratorError13 = false;\n                    var _iteratorError13 = undefined;\n\n                    try {\n                        for (var _iterator13 = answers[type][Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                            var data = _step13.value;\n\n                            data[\"correctanswer\"] = true;\n                            var ans = this.dataToElement(type, data);\n                            //answerselements.push(ans);\n                            this.finished.push(ans);\n                        }\n                    } catch (err) {\n                        _didIteratorError13 = true;\n                        _iteratorError13 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                                _iterator13.return();\n                            }\n                        } finally {\n                            if (_didIteratorError13) {\n                                throw _iteratorError13;\n                            }\n                        }\n                    }\n                }\n                // Draw all answers\n            } catch (err) {\n                _didIteratorError11 = true;\n                _iteratorError11 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                        _iterator11.return();\n                    }\n                } finally {\n                    if (_didIteratorError11) {\n                        throw _iteratorError11;\n                    }\n                }\n            }\n\n            this.update();\n            var _iteratorNormalCompletion12 = true;\n            var _didIteratorError12 = false;\n            var _iteratorError12 = undefined;\n\n            try {\n                for (var _iterator12 = answerselements[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                    var answer = _step12.value;\n\n                    this.draw(answer);\n                }\n            } catch (err) {\n                _didIteratorError12 = true;\n                _iteratorError12 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                        _iterator12.return();\n                    }\n                } finally {\n                    if (_didIteratorError12) {\n                        throw _iteratorError12;\n                    }\n                }\n            }\n        }\n        /**\r\n            Displays cursor data next to the mouse cursor\r\n            @param {Point} cursorpt Location of the cursor\r\n            @param {object} cursordata How the cursor data should look\r\n            @param {string} [cursordata.color=\"black\"] What color the text is written in\r\n            @param {string} [cursordata.font=\"sans-serif\"] What font the text is written in\r\n            @param {string} [cursordata.fontsize=\"16\"] What size the text is written in (in px)\r\n            @param {string} [cursordata.fontstyle=\"bold\"] What style the text is written in\r\n            @param {string} cursordata.format Format of the string to display (use ~x~, ~x2~, ~y~, or ~y2~ for relevant coordinate)\r\n            @param {object} cursordata.digits How many digits to round to for each axis. If using an axis in cursordata.format, it must have a number of digits set.\r\n            @param {int} cursordata.digits.x\r\n            @param {int} cursordata.digits.x2\r\n            @param {int} cursordata.digits.y\r\n            @param {int} cursordata.digits.y2\r\n            @param {number} [cursordata.distance=25] Distance from the center of the cursor to the text display\r\n        */\n\n    }, {\n        key: \"drawCursor\",\n        value: function drawCursor(cursorpt, cursordata) {\n            // Bound cursor within graph\n            if (cursorpt.x) {\n                cursorpt.x = (0, _skyHelpers.constrain)(cursorpt.x, this.graphinfo.x.min, this.graphinfo.x.max);\n            }\n            if (cursorpt.y) {\n                cursorpt.y = (0, _skyHelpers.constrain)(cursorpt.y, this.graphinfo.y.min, this.graphinfo.y.max);\n            }\n            if (cursorpt.x2) {\n                cursorpt.x2 = (0, _skyHelpers.constrain)(cursorpt.x2, this.graphinfo.x2.min, this.graphinfo.x2.max);\n            }\n            if (cursorpt.y2) {\n                cursorpt.y2 = (0, _skyHelpers.constrain)(cursorpt.y2, this.graphinfo.y2.min, this.graphinfo.y2.max);\n            }\n            cursorpt.generateRawFromCal();\n\n            // Align text around cursor\n            var midx = this.graphinfo.graphwidth / 2 + this.graphinfo.padding.left;\n            var midy = this.graphinfo.graphheight / 2 + this.graphinfo.padding.top;\n            var theta = (0, _skyHelpers.getAngle)(cursorpt.rawx, cursorpt.rawy, midx, midy);\n            var cursoralign = 0;\n            var cursorvalign = 0.5;\n            if (theta >= Math.PI) {\n                cursoralign = -theta / Math.PI + 2;\n            } else {\n                cursoralign = theta / Math.PI;\n            }\n            // Default cursor value\n            cursordata.distance = cursordata.distance ? cursordata.distance : 25;\n\n            // Calculate text display location\n            var cursorrawx = cursorpt.rawx;\n            var cursorrawy = cursorpt.rawy;\n            var edgemargin = 5;\n            if (cursorrawx <= this.graphinfo.graphleft) {\n                cursoralign = 0;\n                cursorrawx = this.graphinfo.graphleft + edgemargin;\n            } else if (cursorrawx >= this.graphinfo.graphright) {\n                cursoralign = 1;\n                cursorrawx = this.graphinfo.graphright - edgemargin;\n            } else {\n                cursorrawx += cursordata.distance * Math.cos(theta) / Math.sqrt(Math.abs(Math.cos(theta)));\n            }\n            if (cursorrawy <= this.graphinfo.graphtop) {\n                cursorvalign = 1;\n                cursorrawy = this.graphinfo.graphtop + edgemargin;\n            } else if (cursorrawy >= this.graphinfo.graphbottom) {\n                cursorvalign = 0;\n                cursorrawy = this.graphinfo.graphbottom - edgemargin;\n            } else {\n                cursorrawy += cursordata.distance * Math.sin(theta) / Math.sqrt(Math.abs(Math.sin(theta)));\n            }\n\n            // Fill default arguments\n            var cursorcolor = \"black\";\n            if (cursordata.color != undefined) {\n                cursorcolor = cursordata.color;\n            }\n            var cursorfont = \"sans-serif\";\n            if (cursordata.font != undefined) {\n                cursorfont = cursordata.font;\n            }\n            var cursorfontsize = \"16\";\n            if (cursordata.fontsize != undefined) {\n                cursorfontsize = cursordata.fontsize;\n            }\n            var cursorfontstyle = \"bold\";\n            if (cursordata.fontstyle != undefined) {\n                cursorfontstyle = cursordata.fontstyle;\n            }\n            // Generate text based on cursordata format\n            var content = cursordata.format;\n            if (this.graphinfo.x != undefined) {\n                content = content.replace(SPVAR + \"x\" + SPVAR, cursorpt.x.toFixed(this.cursor.digits.x));\n            }\n            if (this.graphinfo.y != undefined) {\n                content = content.replace(SPVAR + \"y\" + SPVAR, cursorpt.y.toFixed(this.cursor.digits.y));\n            }\n            if (this.graphinfo.x2 != undefined) {\n                content = content.replace(SPVAR + \"x2\" + SPVAR, cursorpt.x2.toFixed(this.cursor.digits.x2));\n            }\n            if (this.graphinfo.y2 != undefined) {\n                content = content.replace(SPVAR + \"y2\" + SPVAR, cursorpt.y2.toFixed(this.cursor.digits.y2));\n            }\n\n            // Draw text\n            var cp = new _Point.Point({\n                \"rawx\": cursorrawx,\n                \"rawy\": cursorrawy,\n                \"graphinfo\": cursorpt.graphinfo,\n                \"show\": false,\n                \"label\": {\n                    \"text\": content,\n                    \"color\": cursorcolor,\n                    \"font\": cursorfont,\n                    \"fontsize\": cursorfontsize,\n                    \"fontstyle\": cursorfontstyle,\n                    \"align\": cursoralign,\n                    \"valign\": cursorvalign } });\n            this.draw(cp);\n            //this.draw(new Text());\n        }\n    }, {\n        key: \"grabElement\",\n        value: function grabElement(pt) {\n            var grabindex = -1;\n            var grabdist = 99999;\n            // Check which object is being picked up\n            for (var i in this.finished) {\n                if (this.finished[i] instanceof _Point.Point) {\n                    // Check if movable\n                    if (this.finished[i].movex || this.finished[i].movey) {\n                        // Check if in grabbing distance\n                        var d = (0, _skyHelpers.getDist)(pt, this.finished[i], \"raw\");\n                        if (d <= this.grabradius) {\n                            if (d < grabdist) {\n                                grabindex = i;\n                                grabdist = d;\n                            }\n                        }\n                    }\n                } else if (this.finished[i] instanceof _Line.Line) {\n                    for (var j = 1; j < this.finished[i].points.length; j++) {\n                        var pt1 = this.finished[i].points[j];\n                        var pt2 = this.finished[i].points[j - 1];\n                        // If either point is immovable, line isn't movable\n                        if (!pt1.movex && !pt1.movey || !pt2.movex && !pt2.movey) {\n                            // If any point is immobile, the line cannot be moved\n                            break;\n                        }\n                        // Shrink grabbing range for line (otherwise assume grabbing a point on either end)\n                        var minx = Math.min(pt1.rawx, pt2.rawx) + this.grabradius;\n                        var maxx = Math.max(pt1.rawx, pt2.rawx) - this.grabradius;\n                        // Check if clicked x is between bounds\n                        if (pt.rawx > minx && pt.rawx < maxx) {\n                            var ytarget = (pt.rawx - pt1.rawx) * (pt2.rawy - pt1.rawy) / (pt2.rawx - pt1.rawx) + pt1.rawy;\n                            var _d = Math.abs(pt.rawy - ytarget);\n                            // Check if in grabbing range of the line\n                            if (_d <= this.grabradius) {\n                                // Check if this is the closest object\n                                if (_d < grabdist) {\n                                    grabindex = i;\n                                    grabdist = _d;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            // If an element was clicked on, pick it up\n            if (grabindex > -1) {\n                this.grabpoint = pt;\n                this.held = this.finished[grabindex];\n                this.finished.splice(grabindex, 1);\n                if (this.held instanceof _Line.Line) {\n                    this.origins = {};\n                    var _iteratorNormalCompletion14 = true;\n                    var _didIteratorError14 = false;\n                    var _iteratorError14 = undefined;\n\n                    try {\n                        for (var _iterator14 = this.held.points[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                            var p = _step14.value;\n\n                            this.origins[p.ID] = new _Point.Point(p.data());\n                            this.deletePointByID(p.ID);\n                        }\n                    } catch (err) {\n                        _didIteratorError14 = true;\n                        _iteratorError14 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                                _iterator14.return();\n                            }\n                        } finally {\n                            if (_didIteratorError14) {\n                                throw _iteratorError14;\n                            }\n                        }\n                    }\n                }\n                // Grabbed something\n                return true;\n            }\n            // Didn't grab anything\n            return false;\n        }\n    }, {\n        key: \"dragElement\",\n        value: function dragElement(pt) {\n            if (this.held instanceof _Point.Point) {\n                // Copy current location data to point\n                if (this.held.movex) {\n                    this.held.rawx = (0, _skyHelpers.constrain)(pt.rawx, this.graphinfo.padding.left, this.graphinfo.padding.left + this.graphinfo.graphwidth);\n                }\n                if (this.held.movey) {\n                    this.held.rawy = (0, _skyHelpers.constrain)(pt.rawy, this.graphinfo.padding.top, this.graphinfo.padding.top + this.graphinfo.graphheight);\n                }\n                // Calculated calibrated positions from new raw position\n                this.held.generateCalFromRaw();\n                // Show held point\n                this.draw(this.held);\n            } else if (this.held instanceof _Line.Line) {\n                // Update location data\n                var rawdx = pt.rawx - this.grabpoint.rawx;\n                var caldx = pt.x - this.grabpoint.x;\n                var rawdy = pt.rawy - this.grabpoint.rawy;\n                var caldy = pt.y - this.grabpoint.y;\n                var _iteratorNormalCompletion15 = true;\n                var _didIteratorError15 = false;\n                var _iteratorError15 = undefined;\n\n                try {\n                    for (var _iterator15 = this.held.points[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                        var p = _step15.value;\n\n                        if (p.movex) {\n                            p.rawx = (0, _skyHelpers.constrain)(this.origins[p.ID].rawx + rawdx, this.graphinfo.padding.left, this.graphinfo.padding.left + this.graphinfo.graphwidth);\n                        }\n                        if (p.movey) {\n                            p.rawy = (0, _skyHelpers.constrain)(this.origins[p.ID].rawy + rawdy, this.graphinfo.padding.top, this.graphinfo.padding.top + this.graphinfo.graphheight);\n                        }\n                        p.generateCalFromRaw();\n                        // Show points\n                        if (p.show) {\n                            this.draw(p);\n                        }\n                    }\n                    // Show held line\n                } catch (err) {\n                    _didIteratorError15 = true;\n                    _iteratorError15 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion15 && _iterator15.return) {\n                            _iterator15.return();\n                        }\n                    } finally {\n                        if (_didIteratorError15) {\n                            throw _iteratorError15;\n                        }\n                    }\n                }\n\n                this.draw(this.held);\n            }\n        }\n    }, {\n        key: \"dropElement\",\n        value: function dropElement(pt) {\n            if (this.held instanceof _Point.Point) {\n                // Copy current location data to point\n                if (this.held.movex) {\n                    this.held.rawx = (0, _skyHelpers.constrain)(pt.rawx, this.graphinfo.padding.left, this.graphinfo.padding.left + this.graphinfo.graphwidth);\n                }\n                if (this.held.movey) {\n                    this.held.rawy = (0, _skyHelpers.constrain)(pt.rawy, this.graphinfo.padding.top, this.graphinfo.padding.top + this.graphinfo.graphheight);\n                }\n                // Calculated calibrated positions from new raw position\n                this.held.generateCalFromRaw();\n                // Add point to finished list\n                this.finished.push(this.held);\n            } else if (this.held instanceof _Line.Line) {\n                var rawdx = pt.rawx - this.grabpoint.rawx;\n                var caldx = pt.x - this.grabpoint.x;\n                var rawdy = pt.rawy - this.grabpoint.rawy;\n                var caldy = pt.y - this.grabpoint.y;\n                var _iteratorNormalCompletion16 = true;\n                var _didIteratorError16 = false;\n                var _iteratorError16 = undefined;\n\n                try {\n                    for (var _iterator16 = this.held.points[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n                        var p = _step16.value;\n\n                        if (p.movex) {\n                            p.rawx = (0, _skyHelpers.constrain)(this.origins[p.ID].rawx + rawdx, this.graphinfo.padding.left, this.graphinfo.padding.left + this.graphinfo.graphwidth);\n                        }\n                        if (p.movey) {\n                            p.rawy = (0, _skyHelpers.constrain)(this.origins[p.ID].rawy + rawdy, this.graphinfo.padding.top, this.graphinfo.padding.top + this.graphinfo.graphheight);\n                        }\n                        p.generateCalFromRaw();\n                        // Show points\n                        if (p.show) {\n                            this.finished.push(p);\n                        }\n                    }\n                    // Add line to finished list\n                } catch (err) {\n                    _didIteratorError16 = true;\n                    _iteratorError16 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion16 && _iterator16.return) {\n                            _iterator16.return();\n                        }\n                    } finally {\n                        if (_didIteratorError16) {\n                            throw _iteratorError16;\n                        }\n                    }\n                }\n\n                this.finished.push(this.held);\n                this.origins = undefined;\n                this.grabpoint = undefined;\n            }\n            // Reset holding\n            this.held = undefined;\n        }\n        /**\r\n            Whenever the mouse is moved over the canvas, update the dynamic layer.\r\n        */\n\n    }, {\n        key: \"mouseMove\",\n        value: function mouseMove(e) {\n            // Get location of event\n\n            var pt = this.getMousePoint(e);\n            this.update();\n\n            // Draw cursor\n            if (this.cursor != undefined) {\n                var cursorpt = new _Point.Point(pt.data());\n                if (this.held) {\n                    if (this.held.altcursor) {\n                        this.drawCursor(cursorpt, this.held.altcursor);\n                    } else {\n                        this.drawCursor(cursorpt, this.cursor);\n                    }\n                } else {\n                    this.drawCursor(cursorpt, this.cursor);\n                }\n            }\n            // If moving objects\n            if (this.mode === \"move\") {\n                // Drag held object\n                if (this.held) {\n                    this.dragElement(pt);\n                }\n                // If drawing\n            } else if (this.drawing) {\n                if (this.mode === \"point\") {\n                    this.draw(pt);\n                } else if (this.mode === \"line\") {\n                    this.draw(new _Line.Line({ \"points\": [this.pt, pt] }));\n                } else if (this.mode === \"calibrate\") {\n                    this.draw(new _Line.Line({ \"points\": [this.pt, pt] }));\n                }\n            }\n        }\n        /**\r\n            Whenever the mouse is released over the canvas\r\n        */\n\n    }, {\n        key: \"mouseUp\",\n        value: function mouseUp(e) {\n            // Get location of event\n            var pt = this.getMousePoint(e);\n            if (this.mode === \"move\") {\n                if (this.held) {\n                    this.dropElement(pt);\n                }\n            } else if (this.mode === \"draw\") {\n                this.drawing = false;\n                if (this.mode === \"point\") {\n                    this.finished.push(pt);\n                } else if (this.mode === \"line\") {\n                    this.finished.push(new _Line.Line({ \"points\": [this.pt, pt] }));\n                } else if (this.mode === \"calibrate\") {\n                    // calibration routine\n                    this.finished.push(new _Line.Line({ \"points\": [this.pt, pt] }));\n                    var x1 = document.getElementById(this.x1).value;\n                    var y1 = document.getElementById(this.y1).value;\n                    var x2 = document.getElementById(this.x2).value;\n                    var y2 = document.getElementById(this.y2).value;\n                    var str = \"let calibration = new Line({\\\"points\\\":[new Point({\\\"rawx\\\":\" + this.pt.rawx + \", \\\"rawy\\\":\" + this.pt.rawy + \", \\\"x\\\":\" + x1 + \", \\\"y\\\":\" + y1 + \"})\";\n                    str += \", new Point({\\\"rawx\\\":\" + pt.rawx + \", \\\"rawy\\\":\" + pt.rawy + \", \\\"x\\\":\" + x2 + \", \\\"y\\\":\" + y2 + \"})]});\";\n                    console.log(\"Copy and paste the line between the bars to use this calibration:\");\n                    console.log(\"-----\");\n                    console.log(str);\n                    console.log(\"-----\");\n                }\n            }\n        }\n        /**\r\n            Whenever the mouse is clicked on the canvas object\r\n        */\n\n    }, {\n        key: \"mouseDown\",\n        value: function mouseDown(e) {\n            // Get location of event\n            var pt = this.getMousePoint(e);\n            if (this.mode == \"move\") {\n                // Check if an element was grabbed\n                if (this.grabElement(pt)) {\n                    this.update();\n                    this.draw(this.held);\n                }\n            } else if (this.mode == \"draw\") {\n                this.pt1 = pt;\n                this.drawing = true;\n            }\n        }\n        /**\r\n            Handle key-press events<br>\r\n            Must be forwarded from {@link ProblemController}\r\n        */\n\n    }, {\n        key: \"keyPress\",\n        value: function keyPress(key) {\n            this.drawing = false;\n            this.calibrating = false;\n            if (key === \"p\") {\n                this.mode = \"point\";\n            } else if (key === \"l\") {\n                this.mode = \"line\";\n            }\n            this.update();\n        }\n    }]);\n\n    return GraphCanvasController;\n}();\n\n//# sourceURL=webpack:///./src/GraphCanvasController.js?");

/***/ }),

/***/ "./src/Graphinfo.js":
/*!**************************!*\
  !*** ./src/Graphinfo.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n    Container class for graph/calibration data\r\n    @param {object} args Object of input arguments.\r\n    @param {int} args.graphheight Height (in px) of the vertical (y) axes\r\n    @param {int} args.graphwidth Width (in px) of the horizontal (x) axes\r\n    @param {string} args.graphbackground Color of the area within the axes\r\n    @param {string} args.axesbackground Color of the area around the graph\r\n    @param {object} args.padding Container for padding size around the plot\r\n        @param {int} args.padding.top Height (in px) of the region above the plot\r\n        @param {int} args.padding.left Width (in px) of the region to the left of the plot\r\n        @param {int} args.padding.bottom Height (in px) of the region below the plot\r\n        @param {int} args.padding.right Width (in px) of the region to the right of the plot\r\n    @param {object} args.x Container for information about the primary x axis\r\n        @param {string} args.x.label Text to label the axis\r\n        @param {float} args.x.min Left/bottom value on the axis\r\n        @param {float} args.x.max Right/top value on the axis\r\n        @param {float} args.x.majortick Increment to draw major tick marks on the axis\r\n        @param {float} args.x.minortick Increment to draw minor tick marks on the axis\r\n        @param {float} args.x.gridline Increent to draw gridlines across the plot\r\n    @param {object} args.y Container for information about the primary y axis (same arguments as {@link x})\r\n    @param {object} args.x2 Container for information about the secondary x axis (same arguments as {@link x})\r\n    @param {object} args.y2 Container for information about the secondary y axis (same arguments as {@link x})\r\n*/\nvar GraphInfo = exports.GraphInfo = function () {\n    function GraphInfo(args) {\n        _classCallCheck(this, GraphInfo);\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = Object.keys(args)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var key = _step.value;\n\n                this[key] = args[key];\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        this.height = this.graphheight + this.padding.bottom + this.padding.top;\n        this.width = this.graphwidth + this.padding.left + this.padding.right;\n        this.graphleft = this.padding.left;\n        this.graphright = this.padding.left + this.graphwidth;\n        this.graphtop = this.padding.top;\n        this.graphbottom = this.padding.top + this.graphheight;\n\n        // Generate calibration values/functions\n        if (this.x != undefined) {\n            this.setupAxis(this.x, this.padding.left, this.graphwidth, this.x.min, this.x.max);\n        }\n        if (this.y != undefined) {\n            this.setupAxis(this.y, this.padding.top, this.graphheight, this.y.max, this.y.min);\n        }\n        if (this.x2 != undefined) {\n            this.setupAxis(this.x2, this.padding.left, this.graphwidth, this.x2.min, this.x2.max);\n        }\n        if (this.y2 != undefined) {\n            this.setupAxis(this.y2, this.padding.top, this.graphheight, this.y2.max, this.y2.min);\n        }\n    }\n    /**\r\n    * TODO\r\n    */\n\n\n    _createClass(GraphInfo, [{\n        key: \"setupAxis\",\n        value: function setupAxis(axis, padding, graphsize, axismin, axismax) {\n            axis.scale = graphsize / (axismax - axismin);\n            axis.CalToRaw = function (cal) {\n                return (cal - axismin) * axis.scale + padding;\n            };\n            axis.RawToCal = function (raw) {\n                return (raw - padding) / axis.scale + axismin;\n            };\n        }\n    }]);\n\n    return GraphInfo;\n}();\n\n//# sourceURL=webpack:///./src/Graphinfo.js?");

/***/ }),

/***/ "./src/Line.js":
/*!*********************!*\
  !*** ./src/Line.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Line = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Text = __webpack_require__(/*! ./Text.js */ \"./src/Text.js\");\n\nvar _skyHelpers = __webpack_require__(/*! ./sky-helpers.js */ \"./src/sky-helpers.js\");\n\nvar _GraphCanvasController = __webpack_require__(/*! ./GraphCanvasController.js */ \"./src/GraphCanvasController.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar IDLENGTH = 16;\n\n/**\r\n    @param {object} args Object-like object of input arguments.\r\n    @param {list} args.points List of {@link Point} constructor argument objects\r\n    @param {string} [args.color=\"black\"]\r\n    @param {float} [args.width=1]\r\n    @param {boolean} [args.answer=false]\r\n    @param {boolean} [args.correctanswer=false]\r\n    @param {object} [args.fill] Fill the region enclosed by the line\r\n    @param {string} args.fill.color Color to fill the region\r\n    @param {float} args.fill.opacity Opacity of the color (0 to 1)\r\n    @param {object} [args.label] Label to go beside the line\r\n    @param {string} [args.label.text] Label contents\r\n    @param {number} [args.label.independent] Location of text (of independent variable)\r\n    @param {number} [args.label.dependent] Location of text (of dependent variable)\r\n*/\n\nvar Line = exports.Line = function () {\n    function Line(args) {\n        _classCallCheck(this, Line);\n\n        /**\r\n            @name Line#ID\r\n            @type string\r\n            @desc (Probably) unique identifier for line. Generated by {@link randomID}.\r\n        */\n        this.ID = (0, _skyHelpers.randomID)(IDLENGTH);\n        /**\r\n            @name Line#color\r\n            @type string\r\n            @default \"black\"\r\n            @desc Line color.\r\n        */\n        this.color = \"black\";\n        /**\r\n            @name Line#width\r\n            @type number\r\n            @default 2\r\n            @desc Line width.\r\n        */\n        this.width = 2;\n        /**\r\n            @name Line#tension\r\n            @type number\r\n            @default 0\r\n            @desc Tension of spline drawn through points (0 is linear)\r\n        */\n        this.tension = 0;\n        /**\r\n            @name Line#layer\r\n            @type number\r\n            @default 1\r\n            @desc Layer to draw element onto\r\n        */\n        this.layer = _GraphCanvasController.LAYERS.UNDER;\n        /**\r\n            @name Line#answer\r\n            @type boolean\r\n            @default false\r\n            @desc Is this line submitted as an answer to the question?\r\n        */\n        this.answer = false;\n        /**\r\n            @name Line#correctanswer\r\n            @type boolean\r\n            @default false\r\n            @desc Is this line a correct answer?\r\n        */\n        this.correctanswer = false;\n        // Fill values from provided arguments\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = Object.keys(args)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var key = _step.value;\n\n                this[key] = args[key];\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n\n    _createClass(Line, [{\n        key: \"draw\",\n        value: function draw(context) {\n            context.save();\n            context.beginPath();\n            context.globalAlpha = 1;\n            context.strokeStyle = this.color;\n            context.lineWidth = this.width;\n            if (this.dashes) {\n                context.setLineDash([this.dashes.dash, this.dashes.space]);\n            }\n            var first = true;\n            // Connect points\n            if (this.tension == 0) {\n                // Draw point-to-point\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = this.points[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var pt = _step2.value;\n\n                        if ((0, _skyHelpers.isBetween)(pt.rawx, this.graphinfo.graphleft, this.graphinfo.graphright) && (0, _skyHelpers.isBetween)(pt.rawy, this.graphinfo.graphtop, this.graphinfo.graphbottom)) {\n                            if (first) {\n                                // Move to start of line\n                                context.moveTo(pt.rawx, pt.rawy);\n                            } else {\n                                // Draw segment\n                                context.lineTo(pt.rawx, pt.rawy);\n                                context.stroke();\n                            }\n                            first = false;\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n            } else {\n                this.drawSpline(context, this.tension);\n            }\n            // Shade tolerance of points\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.points[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var _pt = _step3.value;\n\n                    if (this.correctanswer && _pt.answer) {\n                        // Draw ellipse\n                        context.beginPath();\n                        context.strokeStyle = \"green\";\n                        context.ellipse(_pt.rawx, _pt.rawy, this.tolerance.x * _pt.graphinfo.x.scale, this.tolerance.y * -_pt.graphinfo.y.scale, 0, 0, 2 * Math.PI, false);\n                        //context.stroke();\n                        // Fill circle\n                        context.fillStyle = \"green\";\n                        context.globalAlpha = 0.3;\n                        context.fill();\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            if (this.fill) {\n                context.fillStyle = this.fill.color;\n                context.globalAlpha = this.fill.opacity;\n                context.fill();\n            }\n            if (this.label) {\n                var pos = { \"graphinfo\": this.graphinfo };\n                pos[this.independent.symbol] = this.label.independent;\n                pos[this.dependent.symbol] = this.label.dependent;\n                new _Text.Text({\n                    \"text\": this.label.text,\n                    \"position\": pos,\n                    \"align\": \"center\",\n                    \"color\": this.color,\n                    \"rotate\": this.label.rotate\n                }).draw(context);\n            }\n            context.restore();\n        }\n        /**\r\n        *   Generates control points for use in {@link Line#drawSpline}\r\n        */\n\n    }, {\n        key: \"getControlPoints\",\n        value: function getControlPoints(x0, y0, x1, y1, x2, y2, t) {\n            //  x0,y0,x1,y1 are the coordinates of the end (knot) pts of this segment\n            //  x2,y2 is the next knot -- not connected here but needed to calculate p2\n            //  p1 is the control point calculated here, from x1 back toward x0.\n            //  p2 is the next control point, calculated here and returned to become the\n            //  next segment's p1.\n            //  t is the 'tension' which controls how far the control points spread.\n\n            //  Scaling factors: distances from this knot to the previous and following knots.\n            var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n            var d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n\n            var fa = t * d01 / (d01 + d12);\n            var fb = t - fa;\n\n            var p1x = x1 + fa * (x0 - x2);\n            var p1y = y1 + fa * (y0 - y2);\n\n            var p2x = x1 - fb * (x0 - x2);\n            var p2y = y1 - fb * (y0 - y2);\n\n            return [p1x, p1y, p2x, p2y];\n        }\n        /**\r\n        *   Draws a spline with specified tension <br>\r\n        *   Using example at: http://scaledinnovation.com/analytics/splines/aboutSplines.html\r\n        *   @param {context} context Canvas context to draw onto\r\n        *   @param {float} t Tension to draw the spline with\r\n        */\n\n    }, {\n        key: \"drawSpline\",\n        value: function drawSpline(context, t) {\n            var pts = [];\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = this.points[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var pt = _step4.value;\n\n                    pts.push(pt.rawx);\n                    pts.push(pt.rawy);\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n\n            var cp = [];\n            var n = pts.length;\n            for (var _i = 0; _i < n - 4; _i += 2) {\n                cp = cp.concat(this.getControlPoints(pts[_i], pts[_i + 1], pts[_i + 2], pts[_i + 3], pts[_i + 4], pts[_i + 5], t));\n            }\n            for (var i = 2; i < pts.length - 5; i += 2) {\n                //            if (isBetween(pts[i], this.graphinfo.graphleft, this.graphinfo.graphright) &&\n                //                isBetween(pts[i+1], this.graphinfo.graphtop, this.graphinfo.graphbottom) &&\n                //                isBetween(pts[i+2], this.graphinfo.graphleft, this.graphinfo.graphright) &&\n                //                isBetween(pts[i+3], this.graphinfo.graphtop, this.graphinfo.graphbottom)) {\n                context.beginPath();\n                context.moveTo(pts[i], pts[i + 1]);\n                context.bezierCurveTo(cp[2 * i - 2], cp[2 * i - 1], cp[2 * i], cp[2 * i + 1], pts[i + 2], pts[i + 3]);\n                context.stroke();\n                context.closePath();\n                //            }\n            }\n            //  For open curves the first and last arcs are simple quadratics.\n            //        if (isBetween(pts[0], this.graphinfo.graphleft, this.graphinfo.graphright) &&\n            //            isBetween(pts[1], this.graphinfo.graphtop, this.graphinfo.graphbottom)) {\n            context.beginPath();\n            context.moveTo(pts[0], pts[1]);\n            context.quadraticCurveTo(cp[0], cp[1], pts[2], pts[3]);\n            context.stroke();\n            context.closePath();\n            //        }\n            //        if (isBetween(pts[n-4], this.graphinfo.graphleft, this.graphinfo.graphright) &&\n            //            isBetween(pts[n-3], this.graphinfo.graphtop, this.graphinfo.graphbottom)) {\n            context.beginPath();\n            context.moveTo(pts[n - 2], pts[n - 1]);\n            context.quadraticCurveTo(cp[2 * n - 10], cp[2 * n - 9], pts[n - 4], pts[n - 3]);\n            context.stroke();\n            context.closePath();\n            //        }\n        }\n        /**\r\n            @return {int} The number of line segments\r\n        */\n\n    }, {\n        key: \"segments\",\n        value: function segments() {\n            return this.points.length - 1;\n        }\n        /**\r\n            @return {float} The total distance covered by the line from point to point\r\n        */\n\n    }, {\n        key: \"distance\",\n        value: function distance() {\n            var sum = 0;\n            for (var i = 1; i < this.points.length; i++) {\n                sum += (0, _skyHelpers.getDist)(this.points[i - 1], this.points[i]);\n            }\n            return sum;\n        }\n        /**\r\n            @return {object} The internal data of the line\r\n        */\n\n    }, {\n        key: \"data\",\n        value: function data() {\n            var r = {};\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = Object.keys(this)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var k = _step5.value;\n\n                    r[k] = this[k];\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            return r;\n        }\n    }]);\n\n    return Line;\n}();\n\n//# sourceURL=webpack:///./src/Line.js?");

/***/ }),

/***/ "./src/Modal.js":
/*!**********************!*\
  !*** ./src/Modal.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n*\r\n*/\nvar Modal = exports.Modal = function () {\n    /**\r\n    *\r\n    */\n    function Modal(args) {\n        var _this = this;\n\n        _classCallCheck(this, Modal);\n\n        // Pull in arguments\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = Object.keys(args)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var key = _step.value;\n\n                this[key] = args[key];\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        if (!document.getElementById(this.modalid)) {\n            // Insert modal onto page\n            document.body.insertAdjacentHTML(\"beforeend\", this.getHTML());\n        }\n        // Retrieve html element\n        this.modal = document.getElementById(this.modalid);\n        // Set up listener for 'x' box\n        this.modal.getElementsByClassName(\"close\")[0].onclick = function (e) {\n            return _this.hide();\n        };\n        // Close if clicking outside the box\n        document.addEventListener(\"click\", function (e) {\n            return _this.checkhide(e);\n        });\n    }\n\n    /**\r\n    *\r\n    */\n\n\n    _createClass(Modal, [{\n        key: \"getHTML\",\n        value: function getHTML() {\n            var html = \"<div id=\\\"\" + this.modalid + \"\\\" class=\\\"\" + this.modalclass + \"\\\">\";\n            html += \"<div class=\\\"modal-content\\\">\";\n            html += \"<div class=\\\"modal-header\\\" style=\\\"\";\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = Object.keys(this.headerstyle)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var key = _step2.value;\n\n                    html += key + \":\" + this.headerstyle[key] + \"; \";\n                }\n                //                    color: ${this.color}; background-color:${this.backgroundcolor};\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            html += \"\\\">\";\n            html += \"<span class=\\\"close\\\"> &times; </span>\";\n            html += \"<p>\" + this.header + \"</p>\";\n            html += \"</div>\";\n            html += \"<div class=\\\"modal-body\\\" style=\\\"\";\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = Object.keys(this.contentstyle)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var _key = _step3.value;\n\n                    html += _key + \":\" + this.contentstyle[_key] + \"; \";\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            html += \"\\\">\";\n            html += \"<p>\" + this.content + \"</p>\";\n            html += \"</div>\";\n            html += \"</div>\";\n            html += \"</div>\";\n            return html;\n        }\n\n        /**\r\n        * If clicking outside the modal box, hide it\r\n        */\n\n    }, {\n        key: \"checkhide\",\n        value: function checkhide(e) {\n            if (e.target == this.modal) {\n                this.hide();\n            }\n        }\n\n        /**\r\n        *\r\n        */\n\n    }, {\n        key: \"show\",\n        value: function show() {\n            this.modal.style.display = \"block\";\n            this.showing = true;\n        }\n\n        /**\r\n        *\r\n        */\n\n    }, {\n        key: \"hide\",\n        value: function hide() {\n            this.modal.style.display = \"none\";\n            this.showing = false;\n        }\n\n        /**\r\n        *\r\n        */\n\n    }, {\n        key: \"remove\",\n        value: function remove() {\n            this.modal.remove();\n            delete this;\n        }\n    }]);\n\n    return Modal;\n}();\n\n//# sourceURL=webpack:///./src/Modal.js?");

/***/ }),

/***/ "./src/Point.js":
/*!**********************!*\
  !*** ./src/Point.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Point = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _skyHelpers = __webpack_require__(/*! ./sky-helpers.js */ \"./src/sky-helpers.js\");\n\nvar _Text = __webpack_require__(/*! ./Text.js */ \"./src/Text.js\");\n\nvar _GraphCanvasController = __webpack_require__(/*! ./GraphCanvasController.js */ \"./src/GraphCanvasController.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar IDLENGTH = 16;\n\n// ##### Canvas objects #####\n\n/**\r\n    Objecting representing a point in 2D space\r\n*/\n\nvar Point = exports.Point = function () {\n    /**\r\n        @param {object} args Object of input arguments.\r\n        @param {object} args.graphinfo\r\n        @param {float} args.rawx\r\n        @param {float} args.rawy\r\n        @param {float} args.x\r\n        @param {float} args.y\r\n        @param {boolean} [args.movex=false]\r\n        @param {boolean} [args.movey=false]\r\n        @param {string} [args.color=\"black\"]\r\n        @param {float} [args.radius=5]\r\n        @param {Point} [args.label]\r\n        @param {Point} args.label.text\r\n        @param {Point} [args.label.offset]\r\n        @param {boolean} [args.answer=false]\r\n        @param {boolean} [args.show=true]\r\n    */\n    function Point(args) {\n        _classCallCheck(this, Point);\n\n        /**\r\n            @name Point#graphinfo\r\n            @type GraphInfo\r\n            @desc Relevant information for the graph this point will live on.\r\n        */\n        /**\r\n            @name Point#x\r\n            @type float\r\n            @desc Calibrated x value of point. Must provide either this or {@link Point#rawx}.\r\n        */\n        /**\r\n            @name Point#y\r\n            @type float\r\n            @desc Calibrated y value of point. Must provide either this or {@link Point#rawy}.\r\n        */\n        /**\r\n            @name Point#rawx\r\n            @type float\r\n            @desc Canvas-based x value of point. Must provide either this or {@link Point#x}.\r\n        */\n        /**\r\n            @name Point#rawy\r\n            @type float\r\n            @desc Canvas-based y value of point. Must provide either this or {@link Point#y}.\r\n        */\n        /**\r\n            @name Point#ID\r\n            @type string\r\n            @desc (Probably) unique identifier for point. Generated by {@link randomID}.\r\n        */\n        this.ID = (0, _skyHelpers.randomID)(IDLENGTH);\n        /**\r\n            @name Point#movex\r\n            @type boolean\r\n            @desc Is this point movable in the x dimension?\r\n            @default false\r\n        */\n        this.movex = false;\n        /**\r\n            @name Point#movey\r\n            @type boolean\r\n            @desc Is this point movable in the y dimension?\r\n            @default false\r\n        */\n        this.movey = false;\n        /**\r\n            @name Point#color\r\n            @type string\r\n            @default \"black\"\r\n            @desc Color of the point\r\n        */\n        this.color = \"black\";\n        /**\r\n            @name Point#radius\r\n            @type float\r\n            @default 5\r\n            @desc Radius of the point\r\n        */\n        this.radius = 5;\n        /**\r\n            @name Point#layer\r\n            @type number\r\n            @default 3\r\n            @desc Layer to draw element onto\r\n        */\n        this.layer = _GraphCanvasController.LAYERS.OVER;\n        /**\r\n            @name Point#answer\r\n            @type boolean\r\n            @default false\r\n            @desc Is this point submitted as an answer to the question?\r\n        */\n        this.answer = false;\n        /**\r\n            @name Point#show\r\n            @type boolean\r\n            @default true\r\n            @desc Is this point drawn as part of a line?\r\n        */\n        this.show = true;\n        // Fill values from provided arguments\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = Object.keys(args)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var key = _step.value;\n\n                this[key] = args[key];\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        this.generateMissing();\n        if (this.label) {\n            // Create default offset\n            this.label.offset = this.label.offset ? this.label.offset : { \"rawx\": 0, \"rawy\": 0 };\n            // Add offset to point position\n            this.label.position = { \"rawx\": this.rawx + this.label.offset.rawx, \"rawy\": this.rawy + this.label.offset.rawy };\n            // If still raw data, create text element\n            if (!(this.label instanceof _Text.Text)) {\n                this.label.graphinfo = this.graphinfo;\n                this.label = new _Text.Text(this.label);\n            }\n        }\n    }\n\n    _createClass(Point, [{\n        key: \"draw\",\n        value: function draw(context) {\n            if ((0, _skyHelpers.isBetween)(this.rawx, this.graphinfo.graphleft, this.graphinfo.graphright) && (0, _skyHelpers.isBetween)(this.rawy, this.graphinfo.graphtop, this.graphinfo.graphbottom)) {\n                if (this.show) {\n                    context.save();\n                    if (this.correctanswer) {\n                        // Draw ellipse\n                        context.beginPath();\n                        context.strokeStyle = \"green\";\n                        context.ellipse(this.rawx, this.rawy, this.tolerance.x * this.graphinfo.x.scale, this.tolerance.y * -this.graphinfo.y.scale, 0, 0, 2 * Math.PI, false);\n                        context.stroke();\n                        // Fill circle\n                        context.fillStyle = \"green\";\n                        context.globalAlpha = 0.3;\n                        context.fill();\n                    }\n                    // Black border\n                    context.beginPath();\n                    context.fillStyle = \"black\";\n                    context.globalAlpha = 1;\n                    context.arc(this.rawx, this.rawy, this.radius, 2 * Math.PI, false);\n                    context.fill();\n                    // Colored interior\n                    context.beginPath();\n                    context.fillStyle = this.color;\n                    context.arc(this.rawx, this.rawy, this.radius - 1, 2 * Math.PI, false);\n                    context.fill();\n                    context.restore();\n                }\n                if (this.label != undefined) {\n                    this.label.draw(context);\n                }\n            }\n        }\n        /**\r\n            Sets raw values ({@link Point#rawx}, {@link Point#rawy}) from calibrated values ({@link Point#x}, {@link Point#y}) using {@link Point#graphinfo}.\r\n        */\n\n    }, {\n        key: \"generateMissing\",\n        value: function generateMissing() {\n            if (this.graphinfo === undefined) {\n                console.log(\"Error in Point.generateMissing(), graphinfo not supplied.\", this);\n                return 0;\n            }\n            if (this.graphinfo.x != undefined) {\n                if (this.x === undefined) {\n                    this.x = this.graphinfo.x.RawToCal(this.rawx);\n                } else if (this.rawx === undefined) {\n                    this.rawx = this.graphinfo.x.CalToRaw(this.x);\n                }\n            }\n            if (this.graphinfo.x2 != undefined) {\n                if (this.x2 === undefined) {\n                    this.x2 = this.graphinfo.x2.RawToCal(this.rawx);\n                } else if (this.rawx === undefined) {\n                    this.rawx = this.graphinfo.x2.CalToRaw(this.x2);\n                }\n            }\n            if (this.graphinfo.y != undefined) {\n                if (this.y === undefined) {\n                    this.y = this.graphinfo.y.RawToCal(this.rawy);\n                } else if (this.rawy === undefined) {\n                    this.rawy = this.graphinfo.y.CalToRaw(this.y);\n                }\n            }\n            if (this.graphinfo.y2 != undefined) {\n                if (this.y2 === undefined) {\n                    this.y2 = this.graphinfo.y2.RawToCal(this.rawy);\n                } else if (this.rawy === undefined) {\n                    this.rawy = this.graphinfo.y2.CalToRaw(this.y2);\n                }\n            }\n        }\n    }, {\n        key: \"generateRawFromCal\",\n        value: function generateRawFromCal() {\n            if (this.graphinfo === undefined) {\n                console.log(\"Error in Point.generateMissing(), graphinfo not supplied.\", this);\n                return 0;\n            }\n            if (this.graphinfo.x != undefined) {\n                this.rawx = this.graphinfo.x.CalToRaw(this.x);\n            }\n            if (this.graphinfo.x2 != undefined) {\n                this.rawx = this.graphinfo.x2.CalToRaw(this.x2);\n            }\n            if (this.graphinfo.y != undefined) {\n                this.rawy = this.graphinfo.y.CalToRaw(this.y);\n            }\n            if (this.graphinfo.y2 != undefined) {\n                this.rawy = this.graphinfo.y2.CalToRaw(this.y2);\n            }\n        }\n    }, {\n        key: \"generateCalFromRaw\",\n        value: function generateCalFromRaw() {\n            if (this.graphinfo === undefined) {\n                console.log(\"Error in Point.generateMissing(), graphinfo not supplied.\", this);\n                return 0;\n            }\n            if (this.graphinfo.x != undefined) {\n                this.x = this.graphinfo.x.RawToCal(this.rawx);\n            }\n            if (this.graphinfo.x2 != undefined) {\n                this.x2 = this.graphinfo.x2.RawToCal(this.rawx);\n            }\n            if (this.graphinfo.y != undefined) {\n                this.y = this.graphinfo.y.RawToCal(this.rawy);\n            }\n            if (this.graphinfo.y2 != undefined) {\n                this.y2 = this.graphinfo.y2.RawToCal(this.rawy);\n            }\n        }\n        /**\r\n            @return {object} The internal data of the point\r\n        */\n\n    }, {\n        key: \"data\",\n        value: function data() {\n            var r = {};\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = Object.keys(this)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var k = _step2.value;\n\n                    r[k] = this[k];\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return r;\n        }\n    }]);\n\n    return Point;\n}();\n\n//# sourceURL=webpack:///./src/Point.js?");

/***/ }),

/***/ "./src/Text.js":
/*!*********************!*\
  !*** ./src/Text.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Text = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point.js */ \"./src/Point.js\");\n\nvar _skyHelpers = __webpack_require__(/*! ./sky-helpers.js */ \"./src/sky-helpers.js\");\n\nvar _GraphCanvasController = __webpack_require__(/*! ./GraphCanvasController.js */ \"./src/GraphCanvasController.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar IDLENGTH = 16;\n\n/**\r\n    Text element for display through GraphCanvasController\r\n    @param {string} text Text to display\r\n    @param {string} [font=\"sans-serif\"] Which font to use\r\n    @param {string} [fontsize=\"20\"] Size of the font (in px)\r\n    @param {string} [fontstyle=\"\"] Styling of the font (bold, italic, etc)\r\n    @param {number} [align=\"left\"] Also accepts strings \"left\"=0, \"center\"=0.5, or \"right\"=1\r\n    @param {number} [valign=\"center\"] Also accepts strings \"top\"=0, \"center\"=0.5, or \"bottom\"=1\r\n    @param {string} [color=\"black\"] Color of text\r\n    @param {number} [opacity=1] Opacity of the text\r\n    @param {number} [rotate=0] Rotation of the text (in degrees, clockwise)\r\n    @param {Point} position Location of text on canvas\r\n*/\n\nvar Text = exports.Text = function () {\n    function Text(args) {\n        _classCallCheck(this, Text);\n\n        // Default values\n        this.ID = (0, _skyHelpers.randomID)(IDLENGTH);\n        this.text = \"\";\n        this.font = \"sans-serif\";\n        this.fontsize = \"20\";\n        this.fontstyle = \"\";\n        this.align = \"left\";\n        this.valign = \"center\";\n        this.color = \"black\";\n        /**\r\n            @name Text#layer\r\n            @type number\r\n            @default 3\r\n            @desc Layer to draw element onto\r\n        */\n        this.layer = _GraphCanvasController.LAYERS.OVER;\n        this.opacity = 1;\n        this.rotate = 0;\n        // Argument values\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = Object.keys(args)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var key = _step.value;\n\n                this[key] = args[key];\n            }\n            // Convert data to point if not\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        if (!(this.position instanceof _Point.Point)) {\n            if (this.graphinfo) {\n                this.position.graphinfo = this.graphinfo;\n            }\n            this.position = new _Point.Point(this.position);\n        }\n        // Convert text to string\n        this.text = String(this.text);\n    }\n    /**\r\n        @return {object} The internal data of the text\r\n    */\n\n\n    _createClass(Text, [{\n        key: \"data\",\n        value: function data() {\n            var r = {};\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = Object.keys(this)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var k = _step2.value;\n\n                    r[k] = this[k];\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return r;\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(context) {\n            // Set context variables\n            context.save();\n            context.translate(this.position.rawx, this.position.rawy);\n            context.rotate(this.rotate * Math.PI / 180);\n            // Plan variables\n            var plan = {\n                char: [],\n                x: [0],\n                y: [],\n                font: [],\n                color: [],\n                opacity: []\n            };\n            var subscale = 0.5;\n            var supoff = -.75;\n            var yoff = 0;\n            var charcolor = this.color;\n            var charopacity = this.opacity;\n            // Plan each letter\n            var i = 0;\n            while (i < this.text.length) {\n                while (this.text.charAt(i) === \"<\") {\n                    var command = this.text.slice(i, this.text.indexOf(\">\", i) + 1);\n                    if (command === \"<sub>\") {\n                        this.fontsize *= subscale;\n                    } else if (command === \"</sub>\") {\n                        this.fontsize /= subscale;\n                    } else if (command === \"<sup>\") {\n                        this.fontsize *= subscale;\n                        yoff += this.fontsize * supoff;\n                    } else if (command === \"</sup>\") {\n                        this.fontsize /= subscale;\n                        yoff -= this.fontsize * supoff;\n                    } else if (command.slice(0, 7) === \"<color:\") {\n                        charcolor = command.slice(7, command.indexOf(\">\"));\n                    } else if (command === \"</color>\") {\n                        charcolor = this.color;\n                    } else if (command.slice(0, 9) === \"<opacity:\") {\n                        charopacity = command.slice(9, command.indexOf(\">\"));\n                    } else if (command === \"</opacity>\") {\n                        charopacity = this.opacity;\n                    } else {\n                        console.log('Error in Text.draw(), command not recognized:', command);\n                        break;\n                    }\n                    i += command.length;\n                }\n                // Set plan\n                plan.char.push(this.text.charAt(i));\n                plan.font.push(this.fontstyle + \" \" + this.fontsize + \"px \" + this.font);\n                context.font = plan.font[plan.font.length - 1];\n                plan.color.push(charcolor);\n                plan.opacity.push(charopacity);\n                plan.x.push(plan.x[plan.x.length - 1] + context.measureText(this.text.charAt(i)).width);\n                plan.y.push(yoff);\n                i++;\n            }\n            // Change starting position to account for alignment\n            switch (this.align) {\n                case \"left\":\n                    this.align = 0;\n                    break;\n                case \"center\":\n                    this.align = 0.5;\n                    break;\n                case \"right\":\n                    this.align = 1;\n                    break;\n            }\n            var diff = plan.x[plan.x.length - 1] * this.align;\n            for (i = 0; i < plan.x.length; i++) {\n                plan.x[i] -= diff;\n            }\n\n            // Shift text to middle y based on largest font (capital M is hacky solution)\n            switch (this.valign) {\n                case \"top\":\n                    this.valign = 0;\n                    break;\n                case \"center\":\n                    this.valign = 0.5;\n                    break;\n                case \"bottom\":\n                    this.valign = 1;\n                    break;\n            }\n            context.font = this.fontstyle + \" \" + this.fontsize + \"px \" + this.font;\n            var lineheight = context.measureText('M').width;\n            for (i = 0; i < plan.y.length; i++) {\n                plan.y[i] += lineheight * this.valign;\n            }\n            // Draw letters\n            for (i = 0; i < plan.char.length; i++) {\n                context.font = plan.font[i];\n                context.fillStyle = plan.color[i];\n                context.globalAlpha = plan.opacity[i];\n                context.fillText(plan.char[i], plan.x[i], plan.y[i]);\n            }\n            context.restore();\n        }\n    }]);\n\n    return Text;\n}();\n\n//# sourceURL=webpack:///./src/Text.js?");

/***/ }),

/***/ "./src/ZCanvas.js":
/*!************************!*\
  !*** ./src/ZCanvas.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n    Stacked canvases for drawing on different layers\r\n    @param {int} args.layers Number of layers\r\n    @param {int} args.width Width of canvases\r\n    @param {int} args.height Height of canvases\r\n    @param {string} args.containerid ID of container element\r\n    @param {string} args.containerclass class of container element\r\n    @param {string} args.canvasidprefix ID of each canvas, postpended by its layer number\r\n    @param {string} args.canvasclass Classes added to each canvas\r\n    @param {string} args.parentid ID of element to be inserted into\r\n*/\nvar ZCanvas = exports.ZCanvas = function () {\n    function ZCanvas(args) {\n        _classCallCheck(this, ZCanvas);\n\n        // Pull in arguments\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = Object.keys(args)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var key = _step.value;\n\n                this[key] = args[key];\n            }\n            // If parentid is given, insert html\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        if (document.getElementById(this.parentid)) {\n            document.getElementById(this.parentid).insertAdjacentHTML(\"beforeend\", this.getHTML());\n        }\n        // If elements exist, link to them\n        if (document.getElementById(this.containerid)) {\n            this.link();\n        }\n    }\n\n    /**\r\n    *   Generates the HTML for a ZCanvas container and internal canvases\r\n    *   @returns { string}  The html block\r\n    */\n\n\n    _createClass(ZCanvas, [{\n        key: \"getHTML\",\n        value: function getHTML() {\n            var html = \"<div id=\\\"\" + this.containerid + \"\\\" class=\\\"\" + this.containerclass + \"\\\" style=\\\"position:relative; min-width:\" + this.width + \"px; min-height:\" + this.height + \"px;\\\">\";\n            for (var i = 0; i < this.layers; i++) {\n                html += \"<canvas id=\\\"\" + this.containerid + \"-\" + this.canvasidprefix + i + \"\\\" class=\\\"\" + this.canvasclass + \"\\\" style=\\\"z-index:\" + i + \"; position:absolute;\\\"></canvas>\";\n            }\n            html += \"</div>\";\n            return html;\n        }\n    }, {\n        key: \"link\",\n\n\n        /**\r\n        *   Connects the canvas elements to this object and sets the size\r\n        */\n        value: function link() {\n            if (document.getElementById(\"\" + this.containerid)) {\n                this.canvas = {};\n                this.ctx = {};\n                for (var i = 0; i < this.layers; i++) {\n                    this.canvas[i] = document.getElementById(this.containerid + \"-\" + this.canvasidprefix + i);\n                    this.canvas[i].width = this.width;\n                    this.canvas[i].height = this.height;\n                    this.ctx[i] = this.canvas[i].getContext(\"2d\");\n                }\n                this.updateTopBottom();\n            } else {\n                console.log('Error initializing ZCanvas, does not exist in document yet.', this);\n            }\n        }\n\n        /**\r\n        * Sets 'top' and 'bottom' references to the appropriate layers\r\n        */\n\n    }, {\n        key: \"updateTopBottom\",\n        value: function updateTopBottom() {\n            this.canvas[\"top\"] = this.canvas[this.layers - 1];\n            this.canvas[\"bottom\"] = this.canvas[0];\n            this.ctx[\"top\"] = this.ctx[this.layers - 1];\n            this.ctx[\"bottom\"] = this.ctx[0];\n        }\n    }], [{\n        key: \"getHTMLSkeleton\",\n        value: function getHTMLSkeleton(args) {\n            var html = \"<div id=\\\"\" + args.containerid + \"\\\" class=\\\"\" + args.containerclass + \"\\\" style=\\\"position:relative; min-width:\" + args.width + \"px; min-height:\" + args.height + \"px;\\\">\";\n            for (var i = 0; i < args.layers; i++) {\n                html += \"<canvas id=\\\"\" + args.containerid + \"-\" + args.canvasidprefix + i + \"\\\" class=\\\"\" + args.canvasclass + \"\\\" style=\\\"z-index:\" + i + \"; position:absolute;\\\"></canvas>\";\n            }\n            html += \"</div>\";\n            return html;\n        }\n    }]);\n\n    return ZCanvas;\n}();\n\n//# sourceURL=webpack:///./src/ZCanvas.js?");

/***/ }),

/***/ "./src/hsvToRgb.js":
/*!*************************!*\
  !*** ./src/hsvToRgb.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.hsvToRgb = hsvToRgb;\n/**\r\n* HSV to RGB color conversion\r\n*\r\n* H runs from 0 to 360 degrees\r\n* S and V run from 0 to 100\r\n*\r\n* Ported from the excellent java algorithm by Eugene Vishnevsky at:\r\n* http://www.cs.rit.edu/~ncs/color/t_convert.html\r\n*/\nfunction hsvToRgb(h, s, v) {\n    var r, g, b;\n    var i;\n    var f, p, q, t;\n\n    // Make sure our arguments stay in-range\n    h = Math.max(0, Math.min(360, h));\n    s = Math.max(0, Math.min(100, s));\n    v = Math.max(0, Math.min(100, v));\n\n    // We accept saturation and value arguments from 0 to 100 because that's\n    // how Photoshop represents those values. Internally, however, the\n    // saturation and value are calculated from a range of 0 to 1. We make\n    // That conversion here.\n    s /= 100;\n    v /= 100;\n\n    if (s == 0) {\n        // Achromatic (grey)\n        r = g = b = v;\n        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n    }\n\n    h /= 60; // sector 0 to 5\n    i = Math.floor(h);\n    f = h - i; // factorial part of h\n    p = v * (1 - s);\n    q = v * (1 - s * f);\n    t = v * (1 - s * (1 - f));\n\n    switch (i) {\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n\n        default:\n            // case 5:\n            r = v;\n            g = p;\n            b = q;\n    }\n\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n\n//# sourceURL=webpack:///./src/hsvToRgb.js?");

/***/ }),

/***/ "./src/modalFill.js":
/*!**************************!*\
  !*** ./src/modalFill.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.modalFill = modalFill;\n/**\r\n    For adding more complex HTML content to modals. Imports .txt file as string.\r\n*/\nfunction modalFill(modal, url) {\n    /**\r\n        @param {string} url file location e.g. '../url/src.txt'\r\n        @param {object} modal Modal object from Modal.js file\r\n    */\n    return fetch(url).then(function (response) {\n        // When the page is loaded convert it to text\n        return response.text();\n    }).then(function (doc) {\n        var text = \"\" + doc;\n        return text;\n    }).then(function (text) {\n        var innerhtml = document.getElementById(\"\" + modal.modalid).getElementsByClassName(\"modal-content\")[0].getElementsByClassName(\"modal-body\")[0];\n\n        innerhtml.innerHTML = text;\n        return modal;\n    }).then(function (modal) {\n        return modal.modalid + \" filled\";\n    });\n}\n\n//# sourceURL=webpack:///./src/modalFill.js?");

/***/ }),

/***/ "./src/sky-helpers.js":
/*!****************************!*\
  !*** ./src/sky-helpers.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.getDist = getDist;\nexports.getRandom = getRandom;\nexports.linspace = linspace;\nexports.roundTo = roundTo;\nexports.ifTF = ifTF;\nexports.FindRoot = FindRoot;\nexports.FindRootMulti = FindRootMulti;\nexports.randomID = randomID;\nexports.isIterable = isIterable;\nexports.recursiveReplace = recursiveReplace;\nexports.recursiveNumberfy = recursiveNumberfy;\nexports.recursiveExists = recursiveExists;\nexports.recursiveFind = recursiveFind;\nexports.isBetween = isBetween;\nexports.constrain = constrain;\nexports.generateVariables = generateVariables;\nexports.setCookie = setCookie;\nexports.getCookie = getCookie;\nexports.checkCookie = checkCookie;\nexports.getAngle = getAngle;\nexports.evalWithContext = evalWithContext;\n\nvar _ChemFunctions = __webpack_require__(/*! ./ChemFunctions.js */ \"./src/ChemFunctions.js\");\n\nvar ChemFunction = _interopRequireWildcard(_ChemFunctions);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar VAR = \"@\";\nvar SPVAR = \"~\";\nvar IDLENGTH = 16;\nvar GRABRADIUS = 10;\n\n/**\r\n    Calculates the straight-line distance between two 2D points\r\n    @param {Point} pt1\r\n    @param {Point} pt2\r\n    @param {string} [mode] \"cal\" or \"raw\"\r\n    @return {float} The distance between the points\r\n*/\nfunction getDist(pt1, pt2) {\n    var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"cal\";\n\n    if (mode === \"cal\") {\n        return Math.pow(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2), 0.5);\n    } else if (mode === \"raw\") {\n        return Math.pow(Math.pow(pt1.rawx - pt2.rawx, 2) + Math.pow(pt1.rawy - pt2.rawy, 2), 0.5);\n    }\n}\n\n/**\r\n    Gets a random float between two values\r\n    @param {float} low Lowest value\r\n    @param {float} high Highest value\r\n    @return {float} A float between high and low\r\n*/\nfunction getRandom(low, high) {\n    return Math.random() * (high - low) + low;\n}\n\n/**\r\n *\r\n * @param {*} start\r\n * @param {*} stop\r\n * @param {*} steps\r\n * @param {*} includelast\r\n */\nfunction linspace(start, stop, steps) {\n    var includelast = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    var a = [];\n    var step = (stop - start) / (steps + (includelast ? -1 : 0));\n    var val = start;\n    for (var i = 0; i < steps; i++) {\n        a.push(val + i * step);\n    }\n    return a;\n}\n\n/**\r\n    Rounds a float to a given number of decimal places\r\n    @param {float} num Number to round\r\n    @param {int} digits Number of digits to round to\r\n    @return {float} Rounded number\r\n*/\nfunction roundTo(num, digits) {\n    var mul = Math.pow(10, digits);\n    return Math.round(num * mul) / mul;\n}\n\n/**\r\n    Returns one of two results based on a condition\r\n    @param {string} condition Condition to be tested\r\n    @param {} iftrue Value to return if condition is true\r\n    @param {} iffalse Value to return if condition is false\r\n    @return {boolean} True or false\r\n*/\nfunction ifTF(condition, iftrue, iffalse) {\n    if (condition) {\n        return iftrue;\n    } else {\n        return iffalse;\n    }\n}\n\n/**\r\n * Numerically finds a root of an expression using Newton's method<br>\r\n * TODO: Generalize to multi-variable root finding using Jacobian\r\n * @param { string} args.expression  Equation that is set equal to 0\r\n * @param { string} args.variable    Variable name to replace in equation\r\n * @param { number} args.min     Minimum value to try\r\n * @param { number} args.max     Maximum value to try\r\n * @param { number} args.precision   Allowable error in the answer\r\n * @param { number} [args.initialguess]    Start guessing from here\r\n * @param { int} [args.maxloops=100] Maximum iterations to attempt\r\n * @return { number}     A root of the expression within the precision tolerance\r\n */\nfunction FindRoot(args) {\n    var re = new RegExp(args.variable, \"g\");\n    var loops = 0;\n    var guess = args.guess ? args.guess : (args.min + args.max) / 2;\n    var method = args.method ? args.method : \"newton\";\n    var maxloops = args.maxloops ? args.maxloops : 100;\n    var err = evalWithContext(args.expression.replace(re, guess));\n\n    switch (method) {\n        case \"newton\":\n            var step = (args.max - args.min) / 1000;\n            while (Math.abs(err) > args.precision) {\n                var ss = \"\";\n                for (var z = 0; z < loops; z++) {\n                    ss += \" \";\n                }\n                // Find local derivative at guess\n                var xp = guess + step;\n                var xm = guess - step;\n                var yp = evalWithContext(args.expression.replace(re, xp));\n                var ym = evalWithContext(args.expression.replace(re, xm));\n                var derivative = (yp - ym) / (2 * step);\n                // Find intersection of tangent line\n                if (derivative != 0) {\n                    guess -= err / derivative;\n                } else {\n                    console.log('FindRoot: local minimum found, try a different initial guess.', args);\n                    break;\n                }\n                // Check new guess\n                err = evalWithContext(args.expression.replace(re, guess));\n                // Escape if function does not converge in time\n                loops++;\n                if (loops > maxloops) {\n                    console.log(\"FindRoot exceeding max loops for arguments: \" + args);\n                    break;\n                }\n            }\n            break;\n        case \"bisect\":\n            var low = args.min;\n            var high = args.max;\n            while (Math.abs(err) > args.precision) {\n                var ylow = evalWithContext(args.expression.replace(re, low));\n                var yhigh = evalWithContext(args.expression.replace(re, high));\n                if (Math.abs(ylow) < Math.abs(yhigh)) {\n                    guess = low;\n                    err = ylow;\n                    high -= (low + high) / 2 - low;\n                } else {\n                    guess = high;\n                    err = yhigh;\n                    low += (low + high) / 2 - low;\n                }\n\n                loops++;\n                if (loops > maxloops) {\n                    console.log(\"FindRoot exceeding max loops for arguments: \" + args);\n                    break;\n                }\n            }\n            break;\n    }\n    return guess;\n}\n\n/**\r\n * TODO: use Jacobian to find optimal solution\r\n */\nfunction FindRootMulti(expressions, variables) {\n    var maxloops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = expressions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var expression = _step.value;\n\n            expression.err = expression.precision + 1; // Arbitrary number greater than 0 to initialize\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = variables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var variable = _step2.value;\n\n            variable.guess = variable.guess ? variable.guess : (variable.min + variable.max) / 2;\n            variable.step = Math.min(variable.max - variable.guess, variable.guess - variable.min);\n            variable.re = new RegExp(variable.symbol, \"g\");\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n\n    var loops = 0;\n\n    var systemvalid = false;\n    while (!systemvalid) {\n        loops++;\n        // Assume true\n        systemvalid = true;\n        // Check each equation\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n            for (var _iterator3 = expressions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var _expression = _step3.value;\n\n                var eqn = _expression.equation;\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n\n                try {\n                    for (var _iterator4 = variables[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                        var _variable = _step4.value;\n\n                        eqn = eqn.replace(_variable.re, _variable.guess);\n                    }\n                    // Evaluate expression\n                } catch (err) {\n                    _didIteratorError4 = true;\n                    _iteratorError4 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                            _iterator4.return();\n                        }\n                    } finally {\n                        if (_didIteratorError4) {\n                            throw _iteratorError4;\n                        }\n                    }\n                }\n\n                _expression.err = Math.abs(evalWithContext(eqn)); // 0 err is perfect accuracy\n\n                _expression.valid = _expression.err <= _expression.precision;\n                systemvalid = systemvalid && _expression.valid;\n            }\n        } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                    _iterator3.return();\n                }\n            } finally {\n                if (_didIteratorError3) {\n                    throw _iteratorError3;\n                }\n            }\n        }\n\n        if (loops > maxloops) {\n            console.log(\"FindRootMulti exceeding max loops (\" + maxloops + \") for arguments: (\" + expressions + \", \" + variables + \")\");\n            break;\n        }\n    }\n\n    return variables;\n}\n\n/**\r\n    Generates a string of random digits\r\n    @param {int} digits Number of digits in ID\r\n    @return {string} A string of random digits\r\n*/\nfunction randomID() {\n    var digits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n\n    var str = \"\";\n    // Math.random() generates a 17 digit number between 0 and 1\n    while (digits > 17) {\n        str += String(Math.random() * Math.pow(10, 17));\n        digits -= 17;\n    }\n    str += String(Math.round(Math.random() * Math.pow(10, digits)));\n    while (str.length < digits) {\n        str = \"0\" + str;\n    }\n    return str;\n}\n\n/**\r\n    Determines whether or not an object is iterable\r\n    @param {object} Object to test for iterability\r\n    @return {boolean} True or False\r\n*/\nfunction isIterable(obj) {\n    if (obj == null) {\n        return false;\n    }\n    return typeof obj[Symbol.iterator] === 'export function';\n}\n\n/**\r\n    Performs a replacement on all strings contained in an object\r\n    @param {object} obj Object to replace in\r\n    @param {string} pattern String to find\r\n    @param {string} replacement String to insert\r\n    @return {object} Post-replacement object\r\n*/\nfunction recursiveReplace(obj, pattern, replacement) {\n    if (typeof obj === \"string\") {\n        while (obj.indexOf(pattern) != -1) {\n            obj = obj.replace(pattern, replacement);\n        }\n    } else if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\") {\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n            for (var _iterator5 = Object.keys(obj)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var child = _step5.value;\n\n                obj[child] = recursiveReplace(obj[child], pattern, replacement);\n            }\n        } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                    _iterator5.return();\n                }\n            } finally {\n                if (_didIteratorError5) {\n                    throw _iteratorError5;\n                }\n            }\n        }\n    }\n    return obj;\n}\n\n/**\r\n    Recursively converts all number-like strings in an object into numbers\r\n    @param {object} obj Object to numberfy\r\n    @return {object} Post-conversion object\r\n*/\nfunction recursiveNumberfy(obj) {\n    if (typeof obj === \"string\" && !isNaN(obj)) {\n        obj = parseFloat(obj);\n    } else if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\") {\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n            for (var _iterator6 = Object.keys(obj)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                var child = _step6.value;\n\n                obj[child] = recursiveNumberfy(obj[child]);\n            }\n        } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                    _iterator6.return();\n                }\n            } finally {\n                if (_didIteratorError6) {\n                    throw _iteratorError6;\n                }\n            }\n        }\n    }\n    return obj;\n}\n\n/**\r\n    Tests if a pattern exists on any string contained in an object\r\n    @param {object} obj Object to replace in\r\n    @param {string} pattern String to find\r\n    @return {boolean} True or false\r\n*/\nfunction recursiveExists(obj, pattern) {\n\n    if (typeof obj === \"string\") {\n        while (obj.indexOf(pattern) != -1) {\n            return true;\n        }\n    } else if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\") {\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n            for (var _iterator7 = Object.keys(obj)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                var child = _step7.value;\n\n                if (recursiveExists(obj[child], pattern)) {\n                    return true;\n                }\n            }\n        } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                    _iterator7.return();\n                }\n            } finally {\n                if (_didIteratorError7) {\n                    throw _iteratorError7;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\r\n    Attempts to find a pattern in any string contained in an object\r\n    @param {object} obj Object to replace in\r\n    @param {string} pattern String to find\r\n    @return {list} List of strings containing specified string inside object somewhere\r\n*/\nfunction recursiveFind(obj, pattern) {\n    var findlist = [];\n    if (typeof obj === \"string\") {\n        while (obj.indexOf(pattern) != -1) {\n            return obj;\n        }\n    } else if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\") {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n            for (var _iterator8 = Object.keys(obj)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                var child = _step8.value;\n\n                var f = recursiveFind(obj[child], pattern);\n                if (f) {\n                    if (Array.isArray(f)) {\n                        var _iteratorNormalCompletion9 = true;\n                        var _didIteratorError9 = false;\n                        var _iteratorError9 = undefined;\n\n                        try {\n                            for (var _iterator9 = f[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                                var i = _step9.value;\n\n                                findlist.push(i);\n                            }\n                        } catch (err) {\n                            _didIteratorError9 = true;\n                            _iteratorError9 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                                    _iterator9.return();\n                                }\n                            } finally {\n                                if (_didIteratorError9) {\n                                    throw _iteratorError9;\n                                }\n                            }\n                        }\n                    } else {\n                        findlist.push(f);\n                    }\n                }\n            }\n        } catch (err) {\n            _didIteratorError8 = true;\n            _iteratorError8 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                    _iterator8.return();\n                }\n            } finally {\n                if (_didIteratorError8) {\n                    throw _iteratorError8;\n                }\n            }\n        }\n    }\n    return findlist;\n}\n\n/**\r\n    Generate hash from string <br>\r\n    Bad, need to redo\r\n*/\nString.prototype.hashCode = function () {\n    var hash = 0;\n    if (this.length > 0) {\n        for (var i = 0; i < this.length; i++) {\n            var char = this.charCodeAt(i);\n            hash = (hash << 5) - hash + char;\n            hash = hash & hash; // Convert to 32bit integer\n        }\n    }\n    return hash;\n};\n\n/**\r\n    Returns true if x is between a and b\r\n    @param {num} x Test number\r\n    @param {num} a First boundary\r\n    @param {num} b Second boundary\r\n    @param {boolean} [inclusive=true] Include boundaries\r\n    @return {boolean} True or false\r\n*/\nfunction isBetween(x, a, b) {\n    var inclusive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (inclusive) {\n        return a <= x && x <= b || a >= x && x >= b;\n    } else {\n        return a < x && x < b || a > x && x > b;\n    }\n}\n\n/**\r\n    Returns x if between a and b, otherwise whichever boundary is closer\r\n    @param {float} x Test number\r\n    @param {float} a First boundary\r\n    @param {float} b Second boundary\r\n    @return {float} A number between a and b\r\n*/\nfunction constrain(x, a, b) {\n    var min = Math.min(a, b);\n    var max = Math.max(a, b);\n    return Math.max(Math.min(x, max), min);\n}\n\n/**\r\n    Generates a object of variable values from a object of parameters. Example:<br>\r\n    {\"constants\": {\"x\": 1, \"y\": 2},<br>\r\n    \"random\": {\"z\": {\"min\": -3, \"max\": 3, \"digits\": 1}},<br>\r\n    \"calculated\": {\"sum\": \"@x@+@y@\", \"f\": \"myexport function(@z@)\"}}<br>\r\n    @param {object} variables\r\n    @param {object} variables.constants Constant values\r\n    @param {object} variables.random Linear random variables\r\n    @param {num} variables.random.min Minimum value\r\n    @param {num} variables.random.max Maximum value\r\n    @param {num} variables.random.digits Digits of precision\r\n    @param {object} variables.calculated Variables calculated from other variables, referenced by surrounding in @ symbols\r\n    @return {object} Objectionary of variable names and values\r\n*/\nfunction generateVariables(variables) {\n    var variablevalues = {};\n    // Assign constants\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n        for (var _iterator10 = Object.keys(variables.constants)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n            var name = _step10.value;\n\n            variablevalues[name] = variables.constants[name];\n        }\n        // Generate and assign random variables\n    } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                _iterator10.return();\n            }\n        } finally {\n            if (_didIteratorError10) {\n                throw _iteratorError10;\n            }\n        }\n    }\n\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n        for (var _iterator11 = Object.keys(variables.random)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n            var _name = _step11.value;\n\n            var low = variables.random[_name].min;\n            var high = variables.random[_name].max;\n            var digits = variables.random[_name].digits;\n            var r = getRandom(low, high);\n            variablevalues[_name] = roundTo(r, digits);\n        }\n        // Assign calculated variables\n    } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                _iterator11.return();\n            }\n        } finally {\n            if (_didIteratorError11) {\n                throw _iteratorError11;\n            }\n        }\n    }\n\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n\n    try {\n        for (var _iterator12 = Object.keys(variables.calculated)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n            var _name2 = _step12.value;\n\n            // Construct expression, fill in variable values\n            var exp = variables.calculated[_name2];\n            // Keep replacing until no variables remain\n            var maxloops = 10;\n            var loops = 0;\n            while (exp.indexOf(\"\" + VAR) != -1 && loops < maxloops) {\n                var _iteratorNormalCompletion14 = true;\n                var _didIteratorError14 = false;\n                var _iteratorError14 = undefined;\n\n                try {\n                    for (var _iterator14 = Object.keys(variablevalues)[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                        var variable = _step14.value;\n\n                        exp = exp.replace(\"\" + VAR + variable + VAR, variablevalues[variable]);\n                    }\n                } catch (err) {\n                    _didIteratorError14 = true;\n                    _iteratorError14 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                            _iterator14.return();\n                        }\n                    } finally {\n                        if (_didIteratorError14) {\n                            throw _iteratorError14;\n                        }\n                    }\n                }\n\n                loops++;\n            }\n            if (loops >= maxloops) {\n                console.log(\"Error, maximum loops exceeded, cannot resolve\", _name2, \"=\", exp);\n            }\n            // Evaluate expression (trusted code provided by the question-creator)\n            //console.log(\"Evaluating\",exp);\n            variablevalues[_name2] = evalWithContext(exp);\n        }\n        // Numberfy strings\n    } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                _iterator12.return();\n            }\n        } finally {\n            if (_didIteratorError12) {\n                throw _iteratorError12;\n            }\n        }\n    }\n\n    var _iteratorNormalCompletion13 = true;\n    var _didIteratorError13 = false;\n    var _iteratorError13 = undefined;\n\n    try {\n        for (var _iterator13 = Object.keys(variables.calculated)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n            var _name3 = _step13.value;\n\n            if (typeof variablevalues[_name3] === \"string\" && !isNaN(variablevalues[_name3])) {\n                variablevalues[_name3] = parseFloat(variablevalues[_name3]);\n            }\n        }\n    } catch (err) {\n        _didIteratorError13 = true;\n        _iteratorError13 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                _iterator13.return();\n            }\n        } finally {\n            if (_didIteratorError13) {\n                throw _iteratorError13;\n            }\n        }\n    }\n\n    return variablevalues;\n}\n\n/**\r\n    Creates a new cookie for this page\r\n    @param {string} cname Name of the cookie\r\n    @param {string} cvalue Value of the cookie\r\n    @param {int} milliseconds Lifespan of cookie in ms\r\n*/\nfunction setCookie(cname, cvalue, milliseconds) {\n    var d = new Date();\n    d.setTime(d.getTime() + milliseconds);\n    var expires = \"expires=\" + d.toGMTString();\n    document.cookie = cname + \"=\" + cvalue + \";\" + expires + \";path=/\";\n}\n\n/**\r\n    Retrieves a cookie for this page\r\n    @param {string} cname Name of the cookie\r\n*/\nfunction getCookie(cname) {\n    var name = cname + \"=\";\n    var decodedCookie = decodeURIComponent(document.cookie);\n    var ca = decodedCookie.split(';');\n    for (var i = 0; i < ca.length; i++) {\n        var c = ca[i];\n        while (c.charAt(0) == ' ') {\n            c = c.substring(1);\n        }\n        if (c.indexOf(name) == 0) {\n            return c.substring(name.length, c.length);\n        }\n    }\n    return undefined;\n}\n\n/**\r\n    Example export function for creating/checking a cookie\r\n*/\nfunction checkCookie() {\n    var user = getCookie(\"username\");\n    if (user != \"\") {\n        alert(\"Welcome again \" + user);\n    } else {\n        user = prompt(\"Please enter your name:\", \"\");\n        if (user != \"\" && user != null) {\n            setCookie(\"username\", user, 5 * 1000);\n        }\n    }\n}\n\n/**\r\n * Calculates theta\r\n * @param {number} x1  Base point\r\n * @param {number} y1  Base point\r\n * @param {number} x2  Target point\r\n * @param {number} y2  Target point\r\n * @return {float}  Angle between base and target point\r\n */\nfunction getAngle(x1, y1, x2, y2) {\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var theta = Math.atan(dy / dx);\n    if (dx < 0) {\n        theta += Math.PI;\n    }\n    if (theta < 0) {\n        theta += 2 * Math.PI;\n    } else if (theta > 2 * Math.PI) {\n        theta -= 2 * Math.PI;\n    }\n    return theta;\n}\n\nfunction evalWithContext(code) {\n    // Really need to redo this\n    var Antoine = ChemFunction.Antoine;\n    var InvAntoine = ChemFunction.InvAntoine;\n    var BubblePoint = ChemFunction.BubblePoint;\n    var DewPoint = ChemFunction.DewPoint;\n    return eval(code);\n}\n\n//# sourceURL=webpack:///./src/sky-helpers.js?");

/***/ })

/******/ });