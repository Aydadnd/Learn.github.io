let flashDrum = [[25.3231031543052, 52.80136402387042],[25.861892583120206, 49.02983802216539],[27.20886615515772, 45.52770673486786],[28.82523444160273, 42.56436487638534],[30.710997442455245, 40.13981244671782],[32.86615515771526, 37.7152600170503],[35.290707587382784, 35.56010230179028],[37.9846547314578, 33.135549872122766],[40.67860187553283, 31.24978687127025],[43.372549019607845, 29.63341858482523],[46.33589087809037, 28.017050298380223],[49.29923273657289, 26.670076726342714],[53.34015345268543, 25.0537084398977],[56.84228473998295, 23.976129582267692],[60.34441602728048, 22.62915601023018],[64.65473145780051, 21.55157715260017],[68.15686274509804, 20.743393009377666],[71.92838874680308, 19.665814151747657],[76.2387041773231, 19.127024722932653],[80.81841432225065, 18.85763000852515],[84.85933503836317, 18.58823529411765],[88.90025575447571, 18.049445865302644],[94.28815004262574, 17.78005115089514],[98.86786018755329, 17.78005115089514],[103.44757033248082, 17.78005115089514],[107.48849104859336, 18.04944586530264],[111.26001705029839, 18.58823529411765],[115.03154305200341, 19.12702472293265],[118.80306905370844, 19.66581415174765],[122.57459505541348, 20.20460358056266],[126.34612105711851, 20.47399829497016],[129.84825234441604, 21.55157715260017],[133.08098891730606, 22.62915601023018],[136.58312020460357, 23.70673486786018],[139.81585677749362, 24.51491901108269],[143.58738277919863, 26.13128729752771],[147.62830349531117, 28.01705029838022],[151.9386189258312, 29.902813299232736],[155.44075021312875, 32.32736572890025],[158.40409207161127, 34.75191815856777],[162.1756180733163, 37.4458653026428],[164.60017050298381, 40.67860187553283],[166.75532821824382, 43.91133844842285],[167.83290707587383, 46.87468030690537],[168.64109121909635, 50.3768115942029],[168.91048593350385, 56.84228473998295],[168.91048593350385, 269.1253196930946],[168.10230179028133, 272.8968456947996],[166.48593350383632, 276.9377664109122],[164.33077578857632, 279.9011082693947],[161.6368286445013, 282.86445012787726],[159.21227621483376, 285.5583972719523],[155.97953964194375, 287.9829497016198],[152.4774083546462, 290.1381074168798],[148.97527706734869, 292.5626598465473],[145.20375106564364, 294.4484228473998],[140.8934356351236, 296.06479113384484],[136.8525149190111, 297.6811594202899],[132.27280477408357, 299.0281329923273],[128.23188405797103, 300.1057118499574],[123.92156862745098, 301.1832907075874],[118.26427962489345, 301.9914748508099],[113.6845694799659, 302.7996589940324],[108.56606990622336, 303.3384484228474],[103.98635976129583, 303.8772378516624],[98.86786018755329, 303.8772378516624],[93.47996589940324, 303.6078431372549],[88.3614663256607, 303.6078431372549],[83.24296675191816, 303.3384484228474],[79.74083546462063, 303.0690537084399],[75.4305200341006, 302.26086956521743],[71.12020460358056, 301.9914748508099],[67.34867860187553, 300.9138959931799],[63.307757885763, 299.2975277067349],[58.99744245524297, 298.21994884910487],[55.22591645353794, 296.8729752770674],[51.993179880647915, 295.2566069906223],[47.952259164535384, 293.9096334185848],[44.450127877237854, 291.4850809889173],[40.947996589940324, 289.5993179880648],[37.7152600170503, 287.17476555839727],[33.94373401534527, 284.75021312872974],[31.788576300085253, 282.3256606990622],[30.17220801364024, 280.70929241261723],[28.82523444160273, 278.5541346973572],[27.47826086956522, 275.5907928388747],[26.13128729752771, 272.62745098039215],[25.592497868712705, 268.8559249786871],[25.592497868712705, 264.2762148337596],[25.592497868712705, 56.57289002557545],[25.3231031543052, 52.80136402387042],[25.861892583120206, 49.02983802216539],[27.20886615515772, 45.52770673486786],[28.82523444160273, 42.56436487638534],[30.710997442455245, 40.13981244671782],[32.86615515771526, 37.7152600170503],[35.290707587382784, 35.56010230179028],[37.9846547314578, 33.135549872122766],[40.67860187553283, 31.24978687127025],[43.372549019607845, 29.63341858482523],[46.33589087809037, 28.017050298380223],[49.29923273657289, 26.670076726342714],[53.34015345268543, 25.0537084398977],[56.84228473998295, 23.976129582267692],[60.34441602728048, 22.62915601023018],[64.65473145780051, 21.55157715260017],[68.15686274509804, 20.743393009377666],[71.92838874680308, 19.665814151747657],[76.2387041773231, 19.127024722932653],[80.81841432225065, 18.85763000852515],[84.85933503836317, 18.58823529411765],[88.90025575447571, 18.049445865302644],[94.28815004262574, 17.78005115089514],[98.86786018755329, 17.78005115089514],[103.44757033248082, 17.78005115089514],[107.48849104859336, 18.04944586530264],[111.26001705029839, 18.58823529411765],[115.03154305200341, 19.12702472293265],[118.80306905370844, 19.66581415174765],[122.57459505541348, 20.20460358056266],[126.34612105711851, 20.47399829497016],[129.84825234441604, 21.55157715260017],[133.08098891730606, 22.62915601023018],[136.58312020460357, 23.70673486786018],[139.81585677749362, 24.51491901108269],[143.58738277919863, 26.13128729752771],[147.62830349531117, 28.01705029838022],[151.9386189258312, 29.902813299232736],[155.44075021312875, 32.32736572890025],[158.40409207161127, 34.75191815856777],[162.1756180733163, 37.4458653026428],[164.60017050298381, 40.67860187553283],[166.75532821824382, 43.91133844842285],[167.83290707587383, 46.87468030690537],[168.64109121909635, 50.3768115942029],[168.91048593350385, 56.84228473998295],[168.91048593350385, 269.1253196930946],[168.10230179028133, 272.8968456947996],[166.48593350383632, 276.9377664109122],[164.33077578857632, 279.9011082693947],[161.6368286445013, 282.86445012787726],[159.21227621483376, 285.5583972719523],[155.97953964194375, 287.9829497016198],[152.4774083546462, 290.1381074168798],[148.97527706734869, 292.5626598465473],[145.20375106564364, 294.4484228473998],[140.8934356351236, 296.06479113384484],[136.8525149190111, 297.6811594202899],[132.27280477408357, 299.0281329923273],[128.23188405797103, 300.1057118499574],[123.92156862745098, 301.1832907075874],[118.26427962489345, 301.9914748508099],[113.6845694799659, 302.7996589940324],[108.56606990622336, 303.3384484228474],[103.98635976129583, 303.8772378516624],[98.86786018755329, 303.8772378516624],[93.47996589940324, 303.6078431372549],[88.3614663256607, 303.6078431372549],[83.24296675191816, 303.3384484228474],[79.74083546462063, 303.0690537084399],[75.4305200341006, 302.26086956521743],[71.12020460358056, 301.9914748508099],[67.34867860187553, 300.9138959931799],[63.307757885763, 299.2975277067349],[58.99744245524297, 298.21994884910487],[55.22591645353794, 296.8729752770674],[51.993179880647915, 295.2566069906223],[47.952259164535384, 293.9096334185848],[44.450127877237854, 291.4850809889173],[40.947996589940324, 289.5993179880648],[37.7152600170503, 287.17476555839727],[33.94373401534527, 284.75021312872974],[31.788576300085253, 282.3256606990622],[30.17220801364024, 280.70929241261723],[28.82523444160273, 278.5541346973572],[27.47826086956522, 275.5907928388747],[26.13128729752771, 272.62745098039215],[25.592497868712705, 268.8559249786871],[25.592497868712705, 264.2762148337596],[25.592497868712705, 56.57289002557545]];

// Overall graph shape and graphic on the right
function frame(){
    
    if(!g.show5){
        push();
        scale(.8); translate(160,40);
        push(); // Flash drum
        beginShape(); strokeWeight(2); fill(250);
        for(let i = 0; i < flashDrum.length; i++){
            vertex(430+1.1*flashDrum[i][0],100+.8*flashDrum[i][1]);
        }
        endShape();
        pop();
        arrowDraw();
        figureLabels();
        pop();
    }
    
    function arrowDraw(){
        push();
        strokeWeight(2.5); stroke(g.blue);
        line(width-20,45,width-120,45);
        line(width-120,45,width-120,110)
        arrow([width-120,45],[width-120,120],g.blue,21,5.5);
        line(width-120,340,width-120,400);
        line(width-120,400,width-35,400);
        arrow([width-120,400],[width-25,400],g.blue,21,5.5);
        stroke(g.green);
        line(395,45,490,45);
        line(490,45,490,120);
        arrow([490,45],[390,45],g.green,21,5.5);
        line(390,400,490,400);
        line(490,400,490,342);
        arrow([490,400],[490,335],g.green,21,5.5);
        pop();
    }

    function figureLabels(){
        // Upper right
        push();
        noStroke(); textSize(18); fill(g.blue);
        text('liquid solvent feed',width-160,18);
        if(g.L < 100){
            text('= '+g.L+' Mmol/h',width-115,40);
            textStyle(ITALIC);
            text('L',width-129,40);
        } else {
            text('= '+g.L+' Mmol/h',width-125,40);
            textStyle(ITALIC);
            text('L',width-139,40);
        }
        pop();
        push();
        noStroke(); fill(250);
        rect(width-140,54,120,23);
        textSize(18); fill(g.blue); textStyle(ITALIC);
        text('x',width-135,70);
        textSize(15); textStyle(NORMAL);
        text('0',width-125,75);
        textSize(18);
        text('= '+g.x0.toFixed(2)+' ppm',width-115,70);
        pop();
        
        // Upper left
        push();
        noStroke(); fill(250);
        rect(420,54,120,23);
        textSize(18); fill(g.green); textStyle(ITALIC);
        text('y',425,70);
        textSize(15); textStyle(NORMAL);
        text('1',435,75);
        textSize(18);
        text('= '+g.y1+' ppm',445,70);
        pop();

        // Lower left
        push();
        textStyle(ITALIC); textSize(18); noStroke(); fill(g.green);
        text('V',400,height+20);
        textStyle(NORMAL);
        text(' = 1 Mmol/h',413,height+20);
        text('vapor feed',400,height);
        pop();

        // In the column L/V
        push();
        textStyle(ITALIC); textSize(18); noStroke();
        text('L/V',500,280); 
        textStyle(NORMAL);
        text('= '+g.L,532,280);
        pop();

        // Last stage concentration labels
        push();
        translate(0,-5);
        fill(250); noStroke();
        rect(395,374,130,23); 
        if(g.stagesCount < 9 && g.stagesCount != '∞'){
            textStyle(ITALIC); textSize(18); fill(g.green);
            text('y',400,390);
            textStyle(NORMAL);
            text(' = '+g.yN1+' ppm',420,390);
            textSize(15);
            text(g.stagesCount+1,411,394);
        } else if(g.stagesCount != '∞') {
            textStyle(ITALIC); textSize(18); noStroke(); fill(g.green);
            text('y',400,390);
            textStyle(NORMAL);
            text(' = '+g.yN1+' ppm',428,390);
            textSize(15);
            text(g.stagesCount+1,411,394);
        } 
        fill(250); //noStroke();
        rect(555,374,130,23);
        if(g.stagesCount < 10 && g.stagesCount != '∞'){
            textStyle(ITALIC); textSize(18); fill(g.blue);
            text('x',560,390);
            textStyle(NORMAL);
            text(' = '+g.xOut+' ppm',580,390);
            textSize(15);
            text(g.stagesCount,571,394);
        } else if (g.stagesCount != '∞'){
            textStyle(ITALIC); textSize(18); fill(g.blue);
            text('x',560,390);
            textStyle(NORMAL);
            text(' = '+g.xOut+' ppm',588,390);
            textSize(15);
            text(g.stagesCount,571,394);
        }
        
        pop();

        // Number of stages on absorption column
        if(!g.LVmin){
            push();
            noStroke(); textSize(18);
            if(g.stagesCount == '∞'){
                textSize(27);
                text('∞',466,203);
                textSize(18);
                text('stages needed',487,200);
            } else if(g.stagesCount < 10){
                text(g.stagesCount+' stages needed',470,200);
            } else {
                text(g.stagesCount+' stages needed',465,200);
            }
            pop();
        } else {
            let LVmin = (yeq(g.maxX)-g.y1)/(g.maxX-g.x0);

            push();
            noStroke(); textSize(18); fill(100,0,100);
            text('= '+LVmin.toFixed(1),550,200);
            text('(',477,200);
            text(')',512,200);
            textStyle(ITALIC);
            text('L/V',483,200);
            textSize(15); textStyle(NORMAL);
            text('min',520,203);
            pop();
        }
    }
    

    // Graph shape
    push(); fill(250);
    rect(80,40,320,320);
    textSize(18); noStroke(); fill(0);
    text('solute/(solute-free liquid)     (ppm)',g.lx+30,height-10);
    textStyle(ITALIC); 
    text('x',g.lx+235,height-10);
    textStyle(NORMAL);
    translate(25,330); rotate(radians(-90));
    text('solute/(solute-free vapor)     (ppm)',0,0);
    textStyle(ITALIC);
    text('y',207,0);
    pop();
}

// For drawing the changing axes
function graphAxes(){
    // Y axis
    g.maxY = g.yN1 + 5;
    let ticks, count;
    let xLabels, yLabels;

    if(g.yN1 < 75){
        yLabels = [0,10,20,30,40,50,60,70];
        ticks = 5;
        count = g.maxY/2;
    } else {
        yLabels = [0,20,40,60,80,100,120];
        ticks = 4;
        count = g.maxY/5;
    }

    for(let i = 0; i < count; i++){
        if(i%ticks == 0){
            line(g.lx,g.by-(g.by-g.ty)/count*i,g.lx+5,g.by-(g.by-g.ty)/count*i);
            line(g.rx,g.by-(g.by-g.ty)/count*i,g.rx-5,g.by-(g.by-g.ty)/count*i);
            push();
            noStroke(); textSize(17);
            if(i == 0){
                text(yLabels[i/ticks],g.lx-13,g.by-(g.by-g.ty)/count*i+6);
            } else if(yLabels[i/ticks] > 99){
                text(yLabels[i/ticks],g.lx-32,g.by-(g.by-g.ty)/count*i+6);
            } else {
                text(yLabels[i/ticks],g.lx-23,g.by-(g.by-g.ty)/count*i+6);
            }
            pop();
        } else {
            line(g.lx,g.by-(g.by-g.ty)/count*i,g.lx+3,g.by-(g.by-g.ty)/count*i);
            line(g.rx,g.by-(g.by-g.ty)/count*i,g.rx-3,g.by-(g.by-g.ty)/count*i);
        }
    }

    // X axis
    //g.maxX = Math.round(xeq()*100)/100; 
    g.maxX = xeq();
    if (g.maxX < .8){
        xLabels = [0,.1,.2,.3,.4,.5,.6,.7,.8,.9];
        ticks = 5;
        count = g.maxX/.02;
    } else if (g.maxX <= 1.5){
        xLabels = [0,.2,.4,.6,.8,1,1.2,1.4,1.6];
        ticks = 4;
        count = g.maxX/.05;
    } else {
        xLabels = [0,.5,1,1.5,2];
        ticks = 5;
        count = g.maxX/.1;
    }

    for(let i = 0; i < count; i++){
        if(i%ticks == 0){
            line(g.lx+(g.rx-g.lx)/count*i,g.by,g.lx+(g.rx-g.lx)/count*i,g.by-5);
            line(g.lx+(g.rx-g.lx)/count*i,g.ty,g.lx+(g.rx-g.lx)/count*i,g.ty+5);
            push();
            noStroke(); textSize(17);
            text(xLabels[i/ticks].toFixed(1),g.lx+(g.rx-g.lx)/count*i-12,g.by+20);
            pop();
        } else {
            line(g.lx+(g.rx-g.lx)/count*i,g.by,g.lx+(g.rx-g.lx)/count*i,g.by-3);
            line(g.lx+(g.rx-g.lx)/count*i,g.ty,g.lx+(g.rx-g.lx)/count*i,g.ty+3);
        }
    }
}

function defineLines(){
    let x1, x2, y1, y2;
    
    // Orange line (g.Lo)
    x1 = g.lx; y1 = g.by;
    x2 = g.rx;
    y2 = map(g.yN1,0,g.maxY,g.by,g.ty);

    g.Lo[0] = (y2 - y1)/(x2 - x1);
    g.Lo[1] = y1 - g.Lo[0]*x1;

    // Pink line (g.Up)
    // Values first to be converted to pixels
    x1 = 0; y1 = YN1(0);
    x2 = .2; y2 = YN1(.2);
    x1 = map(x1,0,g.maxX,g.lx,g.rx);
    y1 = map(y1,0,g.maxY,g.by,g.ty);
    x2 = map(x2,0,g.maxX,g.lx,g.rx);
    y2 = map(y2,0,g.maxY,g.by,g.ty);
    g.Up[0] = (y2 - y1)/(x2 - x1);
    g.Up[1] = y1 - g.Up[0]*x1;
}

function displayStages(){
    // Draw boundary curves

    // Orange line
    push();
    strokeWeight(2); stroke(g.orange);
    line(g.lx,g.Lo[0]*g.lx+g.Lo[1],g.rx,g.Lo[0]*g.rx+g.Lo[1]);
    pop();

    // Pink line
    // Need to determine where this line hits on the graph
    let xL, xR, yL, yR;
    yL = g.Up[0]*g.lx + g.Up[1];
    if(yL > g.by){
        yL = g.by;
        xL = (g.by-g.Up[1])/g.Up[0];
    } else {
        xL = g.lx;
    }
    yR = g.Up[0]*g.rx + g.Up[1];
    if(yR < g.ty){
        yR = g.ty;
        xR = (g.ty-g.Up[1])/g.Up[0];
    } else {
        xR = g.rx;
    }
    push();
    strokeWeight(2); stroke(g.pink);
    line(xL,yL,xR,yR);
    pop();

    let x0, y1;

    if(g.rightTest && g.leftTest){
        x0andy1Disp();
        stagesSolveAndDisp();
    } else {
        infStages();
    }

    function x0andy1Disp(){
        x0 = map(g.x0,0,g.maxX,g.lx,g.rx);
        y1 = map(g.y1,0,g.maxY,g.by,g.ty);
        
        push();
        drawingContext.setLineDash([5,5]); strokeWeight(2);
        stroke(g.blue);
        line(x0,g.by,x0,y1);
        stroke(g.green);
        line(g.lx,y1,x0,y1);
        pop();

        push();
        noStroke(); fill(250);
        rect(x0-12,g.by+6,23,18);
        rect(g.lx-26,y1-7,23,18);
        textSize(19); fill(g.blue); textStyle(ITALIC);
        text('x',x0-9,g.by+18);
        fill(g.green);
        text('y',g.lx-23,y1+5);
        textStyle(NORMAL); textSize(14);
        fill(g.blue);
        text('0',x0+1,g.by+22);
        fill(g.green);
        text('1',g.lx-13,y1+9);
        pop();

        push();
        noStroke(); fill(g.blue);
        ellipse(x0,g.by,g.diam);
        fill(g.green);
        ellipse(g.lx,y1,g.diam);
        pop();
    }   

    function infStages(){
        push();
        fill(250);
        rect(g.lx+60,g.ty+134,200,41);
        fill(255,0,0); noStroke(); textSize(18);
        text('separation not possible',g.lx+68,g.ty+150);
        fill(0);
        text('*inifinite stages needed*',g.lx+65,g.ty+170);
        pop();
    }
    
}

function stagesSolveAndDisp(){
    let xLim = map(g.x0,0,g.maxX,g.lx,g.rx);
    let yStart = map(g.yN1,0,g.maxY,g.by,g.ty);

    // xStart variable used to determine number of stages
    let xStart = (yStart - g.Up[1])/g.Up[0];
    let count = 0;
    let x = 10000; 
    let y;

    let p = [];
    p.push([xStart,yStart]);

    g.xOut = (map(xStart,g.lx,g.rx,0,g.maxX)).toFixed(2);

    while(x > xLim && count < 100){
        // Find next vertical point (orange line)
        if(count == 0){
            x = xStart;
            y = g.Lo[0]*xStart + g.Lo[1];
        } else {
            y = g.Lo[0]*x + g.Lo[1];
        }
        
        p.push([x,y]);

        // Find next horizontal point (pink line)
        x = (y - g.Up[1])/g.Up[0];
        
        // Test if x < xLim
        if(x < xLim){
            x = xLim;
        }
        p.push([x,y]);
        count++;
        
    }

    g.stagesCount = (p.length-1)/2;

    push();
    strokeWeight(2);
    for(let i = 0; i < p.length-1; i++){
        line(p[i][0],p[i][1],p[i+1][0],p[i+1][1]);
    }
    pop();

    // Vertical dashed line for last x stage
    push();
    strokeWeight(2); drawingContext.setLineDash([5,5]); stroke(g.blue);
    line(p[1][0],p[1][1],p[1][0],g.by);
    noStroke(); fill(g.blue);
    ellipse(p[1][0],p[1][1],g.diam);
    pop();

    // Y1 line
    push();
    strokeWeight(2); stroke(g.green); drawingContext.setLineDash([5,5]);
    line(g.lx,yStart,g.rx,yStart);
    pop();

    // Text labels for last x stage and last y stage
    push();
    fill(250); noStroke();
    if(g.stagesCount < 9){
        rect(g.lx+51,yStart-8,21,20);
    } else {
        rect(g.lx+51,yStart-8,29,20);
    }
    if(g.stageCount < 10){
        rect(p[1][0]-10,g.by-62,21,20);
    } else {
        rect(p[1][0]-10,g.by-62,29,20);
    }
    
    textSize(16); textStyle(ITALIC); fill(g.green);
    text('y',g.lx+55,yStart+3);
    fill(g.blue);
    text('x',p[1][0]-7,g.by-50);
    textStyle(NORMAL); textSize(13);
    text(g.stagesCount,p[1][0]+1,g.by-45);
    fill(g.green);
    text(g.stagesCount+1,g.lx+63,yStart+7);
    pop();

    if(g.stagesCount < 10){
        for(let i = 1; i < 2*g.stagesCount; i+= 2){
            push();
            noStroke(); textSize(17); 
            text(g.stagesCount-.5*(i-1),p[i][0]+5,p[i][1]+10)
            pop();
        }
    } else {
        push();
        noStroke(); textSize(17);
        text('1',p[p.length-2][0]+5,p[p.length-2][1]+10);
        for(let i = 1; i < 16; i+=2){
            text(g.stagesCount-.5*(i-1),p[i][0]+5,p[i][1]+10);
        }
        pop();
    }

    
}

function equilibLines(){
    if(mouseX > g.lx && mouseX < g.rx && mouseY > g.ty && mouseY < g.by){
        x = mouseX;
        y = mouseY;
        let check = true;

        let yL, yU, theta;
        yL = g.Lo[0]*x + g.Lo[1];
        yU = g.Up[0]*x + g.Up[1];

        // For figuring out the angle on equilib line
        let x1, x2, y1, y2;
        x1 = g.lx; y1 = g.Lo[0]*g.lx + g.Lo[1];
        x2 = g.rx; y2 = g.Lo[0]*g.rx + g.Lo[1];

        theta = Math.atan((y2-y1)/(x2-x1));
        if(mouseY <= yL+7 && mouseY >= yL-7){
            check = false;

            // Remapping x1 to a value to start text at
            x = g.lx+40;
            y = g.Lo[0]*x + g.Lo[1];
            push();
            translate(x+45,y); rotate(theta);
            noStroke(); textSize(16); fill(g.orange);
            text('operating line',0,0);
            pop();
        }

        // Rewriting for operating line
        y1 = g.Up[0]*x1 + g.Lo[1];
        y2 = g.Up[0]*x2 + g.Up[1];
        theta = Math.atan((y2-y1)/(x2-x1));

        if(check && mouseY <= yU+7 && mouseY >= yU-7){
            x = g.lx+40;
            y = g.Up[0]*x + g.Up[1];
            push();
            translate(x-10,y-2); rotate(theta);
            noStroke(); textSize(16); fill(g.pink);
            text('equilibrium line',0,0);
            pop();
        }

    }
}

function LVminDisp(){
    let x1, y1, x2, y2;
    x1 = g.lx;
    y1 = map((yeq(g.maxX)-g.y1)/(g.maxX - g.x0)*(-g.x0) + g.y1,0,g.maxY,g.by,g.ty);
    x2 = g.rx;
    y2 = map((yeq(g.maxX)-g.y1)/(g.maxX - g.x0)*(g.maxX-g.x0) + g.y1,0,g.maxY,g.by,g.ty);

    push();
    strokeWeight(2); stroke(g.pink);
    line(x1,y1,x2,y2);
    stroke(g.orange);
    line(g.lx,g.by,x2,y2);
    pop();
}

function infiniteStageTest(){
    let yTest;

    // Left side test (is pink line lower than orange line at left x-axis lim)
    yTest = g.Up[0]*g.lx + g.Up[1];

    if(yTest > g.by){
        g.leftTest = false;
    } else {
        g.leftTest = true;
    }

    // Right side test (is pink line lower than orange line at right x-axis lim)

    yTest = g.Up[0]*g.rx + g.Up[1];
    let yComp = map(g.yN1,0,g.maxY,g.by,g.ty);
    
    if(yTest >= yComp){
        g.rightTest = false;
        g.stagesCount = '∞';
    } else {
        g.rightTest = true;
    }
}

function show5Display(){
    let xLabels = ['0.0','0.1','0.2','0.3','0.4','0.5','0.6'];
    let yLabels = ['0','10','20','30','40','50','60'];
    let flux = [21.6,36.5,54.1,74.9,99.6];
    let x = [0.05,0.12,0.20,0.29,0.41,0.54];
    let y = [10,17,25,34,46,59];


    figure();
    graphAxes();
    curves();
    graphText();
    // Figure on the right and all text associated
    function figure(){
        push();
        scale(.8); translate(160,40);
        push();
        textSize(22); noStroke();
        text('mole ratios are in ppm',435,-15);
        pop();
        translate(0,10);

        push();
        for(let i = 1; i < 6; i++){
            if(i == g.stage){
                strokeWeight(4); fill(255,255,0);
                rect(480,50+70*(i-1),110,40);
                push();
                textSize(30); fill(0); 
                text(i,525,81+70*(i-1));
                pop();
            } else {
                strokeWeight(1.5); fill(250);
                rect(480,50+70*(i-1),110,40)
                push();
                textSize(22); fill(0); 
                text(i,528,77+70*(i-1));
                pop();
            }
        }
        pop();
        push();
        strokeWeight(2); 
        for(let i = 0; i < 5; i++){
            stroke(g.blue);
            line(565,20+70*i,565,45+70*i);
            arrow([565,10+70*i],[565,50+70*i],g.blue,20,6);
            stroke(g.green);
            line(505,470-70*(i+1),505,442-70*(i+1));
            arrow([505,600-70*(i+1)],[505,439-70*(i+1)],g.green,20,6);
        }

        // Other arrows and lines
        line(480,400,505,400);
        line(490,20,505,20);
        line(505,20,505,50);
        arrow([505,20],[470,20],g.green,20,6);
        stroke(g.blue);
        line(565,370,565,400);
        line(565,400,580,400);
        arrow([565,400],[600,400],g.blue,20,6);
        line(590,20,565,20);
        pop();

        // Non-italic elements
        push();
        textSize(22); noStroke();
        fill(g.green);
        text('1 Mmol/h',400,5);
        text('1 Mmol/h',400,425);
        fill(g.blue);
        text('100 Mmol/h',580,5);
        text('100 Mmol/h',580,425);
        pop();

        // Value labels for x and y
        push();
        noStroke(); textSize(20); 
        for(let i = 0; i < 5; i++){
            if(i == 0){
                fill(g.green);
                text(' = '+y[0],430,45);
                text(' = '+y[y.length-1],430,395);
                push();
                textStyle(ITALIC);
                text('y',410,45);
                text('y',410,395);
                pop();
                push();
                textSize(16);
                text('1',421,52);
                text('6',421,402);
                pop();
                fill(g.blue);
                text(' = '+x[0],630,45);
                text(' = '+x[x.length-1],630,395);
                push();
                textStyle(ITALIC);
                text('x',610,45);
                text('x',610,395);
                pop();
                push();
                textSize(16);
                text('0',621,52);
                text('5',621,402);
                pop();

            } else {
                fill(g.green);
                text(' = '+y[i],450,40+70*(i));
                push();
                textStyle(ITALIC);
                text('y',430,40+70*(i));
                pop();
                push();
                textSize(16);
                text(i+1,441,47+70*i);
                pop();
                fill(g.blue);
                if(i == 2){
                    text(' = 0.20',600,40+70*i);  
                } else {
                    text(' = '+x[i],600,40+70*i);  
                }
                push();
                textStyle(ITALIC);
                text('x',580,40+70*i);
                pop();
                push();
                textSize(16);
                text(i,591,47+70*i);
                pop();
            }
        }
        pop();
        pop();
    }

    // Tick marks on x and y axes + labels
    function graphAxes(){
        // X-ticks
        let ticks = 5;
        let count = .7/.02;
        for(let i = 0; i < count; i++){
            if(i%ticks == 0){
                line(g.lx+(g.rx-g.lx)/count*i,g.by,g.lx+(g.rx-g.lx)/count*i,g.by-5);
                line(g.lx+(g.rx-g.lx)/count*i,g.ty,g.lx+(g.rx-g.lx)/count*i,g.ty+5);
                push();
                noStroke(); textSize(17);
                text(xLabels[i/ticks],g.lx+(g.rx-g.lx)/count*i-10,g.by+20);
                pop();
            } else {
                line(g.lx+(g.rx-g.lx)/count*i,g.by,g.lx+(g.rx-g.lx)/count*i,g.by-3);
                line(g.lx+(g.rx-g.lx)/count*i,g.ty,g.lx+(g.rx-g.lx)/count*i,g.ty+3);
            }
        }
        // Y-ticks
        count = 64/2;
        for(let i = 0; i < count; i++){
            if(i%ticks == 0){
                line(g.lx,g.by-(g.by-g.ty)/count*i,g.lx+5,g.by-(g.by-g.ty)/count*i);
                line(g.rx,g.by-(g.by-g.ty)/count*i,g.rx-5,g.by-(g.by-g.ty)/count*i);
                push();
                noStroke(); textSize(17);
                if(i == 0){
                    text(yLabels[i/ticks],g.lx-13,g.by-(g.by-g.ty)/count*i+6);
                } else {
                    text(yLabels[i/ticks],g.lx-23,g.by-(g.by-g.ty)/count*i+6);
                }
                
                pop();
            } else {
                line(g.lx,g.by-(g.by-g.ty)/count*i,g.lx+3,g.by-(g.by-g.ty)/count*i);
                line(g.rx,g.by-(g.by-g.ty)/count*i,g.rx-3,g.by-(g.by-g.ty)/count*i);
            }
        }
    }

    // Draws the curve and connection points on the graph
    function curves(){
        let x1, x2, y1, y2;
        x1 = map(x[0],0,.7,g.lx,g.rx);
        x2 = map(x[1],0,.7,g.lx,g.rx);
        y1 = map(y[0],0,64,g.by,g.ty);
        y2 = map(y[1],0,64,g.by,g.ty);

        let m = (y2 - y1)/(x2 - x1);
        let b = y1 - m*x1;
        let yL, xR;

        yL = m*g.lx + b;
        xR = (g.ty - b)/m;

        push(); strokeWeight(2); stroke(g.pink);
        line(g.lx,yL,xR,g.ty);
        pop();

        x1 = map(0,0,.7,g.lx,g.rx);
        x2 = map(.7,0,.7,g.lx,g.rx);
        y1 = map(0,0,64,g.by,g.ty);
        y2 = map(59,0,64,g.by,g.ty);
        m1 = (y2 - y1)/(x2 - x1);
        b1 = y1 - m*x1;
        // let xL = (g.by-b1)/m1;
        // let yR = m1*g.rx + b1;

        push(); strokeWeight(2); stroke(g.orange); 
        line(x1,y1,x2,y2);
        pop();

        
        for(let i = 1; i < 6; i++){
            x1 = map(x[i],0,.7,g.lx,g.rx);
            y1 = map(y[i-1],0,64,g.by,g.ty);
            y2 = map(y[i],0,64,g.by,g.ty);
            x2 = map(x[i-1],0,.7,g.lx,g.rx);
            if(i == 4){
                x1 = x1 - 1;
                y1 = y1 - 1;
            } else if(i == 5){
                x1 = x1 + 1; 
                y1 = y1 + 1;
            } else if(i == 3){
                x1 = x1 + 1;
                y1 = y1 + 1;
            }
            push();
            strokeWeight(2);
            line(x1,y1,x1,y2);
            line(x2,y1,x1,y1);
            pop();
        }
        for(let i = 0; i < 6; i++){
            if(i == 0){
                x1 = map(0.05,0,.7,g.lx,g.rx);
                y1 = map(10,0,64,g.by,g.ty);
                push(); fill(g.blue); noStroke();
                ellipse(x1,g.by,9);
                fill(g.green);
                ellipse(x1,y1,9);
                pop();
            } else {
                x1 = map(x[i],0,.7,g.lx,g.rx);
                y1 = map(y[i-1],0,64,g.by,g.ty);
                y2 = map(y[i],0,64,g.by,g.ty);
                x2 = map(x[i-1],0,.7,g.lx,g.rx);
                if(i == 4){
                    x1 = x1 - 1;
                    y1 = y1 - 1;
                } else if (i == 5){
                    x1 = x1 + 1;
                    y1 = y1 + 1;
                } else if(i == 3){
                    x1 = x1 + 1;
                    y1 = y1 + 1;
                }
                
                push();
                fill(g.blue); noStroke();
                ellipse(x1,y1,9);
                pop();
                push();
                fill(g.green); noStroke(); 
                ellipse(x1,y2,9);
                pop();
                
            }
        }

        push();
        strokeWeight(2); stroke(g.green); drawingContext.setLineDash([5,5]);
        line(g.lx,y2,g.lx+51,y2);
        line(g.lx+75,y2,g.rx,y2);
        pop();
       
    }

    // All the text and labels on the graph
    function graphText(){
        push();
        noStroke(); textSize(16);

        // Flux label
        text('stage '+g.stage+' solute fluxes:',g.lx+10,g.ty+60);
        text('in: '+flux[g.stage-1]+' mol/h',g.lx+40,g.ty+80);
        text('out: '+flux[g.stage-1]+' mol/h',g.lx+33,g.ty+100);

        // Equilibrium statement
        text('is in equilibrium with',g.lx+100,g.by-15);
        push();
        fill(g.green); textStyle(ITALIC);
        text('y',g.lx+80,g.by-15);
        fill(g.blue);
        text('x',g.lx+248,g.by-15);
        textStyle(NORMAL); textSize(14);
        text('n',g.lx+256,g.by-11);
        fill(g.green);
        text('n',g.lx+88,g.by-11);
        pop();

        // Top and bottom labels
        push(); strokeWeight(1);
        fill(250);
        rect(g.lx+6,g.by-37.5,25,17);
        fill(0);
        text('top',g.lx+8,g.by-25);
        text('bottom',g.rx-56,g.ty+20);
        pop();

        // Point labels
        text('1,     ,',145,320);
        text('2,     ,',180,285);
        text('3,     ,',225,245);
        text('4,     ,',275,200);
        text('5,     ,',335,145);
        textStyle(ITALIC);
        fill(g.blue);
        text('x',165,320);
        text('x',200,285);
        text('x',245,245);
        text('x',295,200);
        text('x',355,145);
        text('x',g.lx+27,g.by-10);
        fill(g.green);
        text('y',190,320);
        text('y',225,285);
        text('y',270,245);
        text('y',320,200);
        text('y',380,145);
        text('y',g.lx+55,68);

        textStyle(NORMAL); textSize(13);
        fill(g.blue);
        text('0',g.lx+35,g.by-6);
        text('1',173,324);
        text('2,',208,289);
        text('3',253,249);
        text('4',303,204);
        text('5',363,149);
        fill(g.green);
        text('1',198,324);
        text('2',233,289);
        text('3',278,249);
        text('4',328,204);
        text('5',388,149);
        text('6',g.lx+63,72);
        pop();
    }
}

// For creating arrows
function arrow(base,tip,color,arrowLength,arrowWidth){ 
    // base = [x,y] tip = [x,y]
    // let arrowLength = 20; // Length of arrow
    // let arrowWidth = 5; // width of arrow (1/2)
    let dx, dy, mag;
    let u_hat, u_perp;
    let point = new Array(2); // Point along unit vector that is base of triangle
    let vert = new Array(6); // Holds vertices of arrow
    // Need to define a unit vector
    dx = tip[0] - base[0];
    dy = tip[1] - base[1];
    mag = (dx**2 + dy**2)**(1/2);
    u_hat = [dx/mag,dy/mag];
    vert[0] = tip[0] - 2*u_hat[0]; // Shifts the arrow back some to keep the tip from going out too far
    vert[1] = tip[1] - 2*u_hat[1];
    // Perpendicular unit vector
    u_perp = [-u_hat[1],u_hat[0]];
    // Base of arrow
    point[0] = vert[0]+ -arrowLength*u_hat[0];
    point[1] = vert[1]+ -arrowLength*u_hat[1];
    
    vert[2] = point[0] + u_perp[0]*arrowWidth;
    vert[3] = point[1] + u_perp[1]*arrowWidth;
    vert[4] = point[0] + -u_perp[0]*arrowWidth;
    vert[5] = point[1] + -u_perp[1]*arrowWidth;
    push();
    stroke(color); fill(color); strokeWeight(1);
    triangle(vert[0],vert[1],vert[2],vert[3],vert[4],vert[5]);
    pop();
  
}

// Equation functions
function HB(){
    return(g.H0*Math.E**((-g.Ea/g.R)*(1/(g.T+273)-1/g.T0)))
}

function YN1(x){
    return(g.L*(x-g.x0) + g.y1)
}

function yeq(x){
    return(HB()*x/g.P);
}

function xeq(){
    let x = g.yN1*g.P/HB();
    return(x);
}